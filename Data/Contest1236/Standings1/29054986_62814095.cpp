/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author aajisaka
 */

#include<bits/stdc++.h>

using namespace std;

void debug_out() { cerr << endl; }
template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
  cerr << " " << to_string(H);
  debug_out(T...);
}
#ifdef LOCAL
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)
#define rep(i,n) for(int i=0; i<(int)(n); i++)
#define all(v) v.begin(), v.end()
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }

using ll = long long;
using P = pair<ll, ll>;

constexpr double PI = 3.14159265358979323846;
mt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());

int maxN;

class EAliceAndTheUnfairGame {
public:

    // update by range, query by point
    struct SegTree {
        int N;
        vector<long long> dat;

        void init(int n) {
          N = 1;
          while(N < n) N *= 2;
          dat.resize(2*N-1, 0);
        }

        // add [a, b) by x
        void add(int a, int b, long long x) {
          return add(a, b, x, 0, 0, N);
        }
        void add(int a, int b, ll x, int k, int l, int r) {
          if (r <= a || b <= l) return;
          if (a <= l && r <= b) {
            dat[k] += x;
            return;
          }
          int m = (l+r)/2;
          add(a, b, x, k*2+1, l, m);
          add(a, b, x, k*2+2, m, r);
        }

        // return k
        ll query(int k) {
          k += N-1;
          ll ret = dat[k];
          while(k > 0) {
            k = (k-1)/2;
            ret += dat[k];
          }
          return ret;
        }

        int lower_bound(long long val, int min, int max) {
          if (query(max) < val) return maxN;
          if (query(0) >= val) return 0;
          while (min + 1 < max) {
            int now = (min + max) / 2;
            if (query(now) >= val) {
              max = now;
            } else {
              min = now;
            }
          }
          return max;
        }

        int upper_bound(long long val, int min, int max) {
          if (query(max) <= val) return maxN;
          if (query(0) > val) return 0;
          while (min + 1 < max) {
            int now = (min + max) / 2;
            if (query(now) > val) {
              max = now;
            } else {
              min = now;
            }
          }
          return max;
        }
    };

    void solve(istream& cin, ostream& cout) {
      SPEED;
      int n, m; cin >> n >> m;

      if (n==1) {
        cout << 0 << endl;
        return;
      }


      maxN = n;
      vector<int> a(m);
      rep(i, m) {
        cin >> a[i];
      }
      SegTree tree;
      tree.init(n);
      rep(i, n) {
        tree.add(i, n, 1);
      }
      rep(i, m) {
        int mi = -1;
        int ma = n;
        int k = tree.lower_bound(a[i]-1, -1, n-1);
        int s = tree.upper_bound(a[i]-1, -1, n-1);
        debug(k, s);
        tree.add(0, k, 1);
        tree.add(s, n, 1);
      }
      tree.add(0, n, 1);

      SegTree tree2;
      tree2.init(n);
      rep(i, n) {
        tree2.add(i, n, 1);
      }
      rep(i, m) {
        int mi = -1;
        int ma = n;
        int k = tree2.lower_bound(a[i]+1, -1, n-1);
        int s = tree2.upper_bound(a[i]+1, -1, n-1);
        debug(k, s);
        tree2.add(0, k, -1);
        tree2.add(s, n, -1);
      }
      tree2.add(0, n, -1);

      ll ans = 0;
      rep(i, n) {
        debug(tree.query(i), tree2.query(i));
        int s = max(1LL, tree2.query(i));
        int t = min((ll)n, tree.query(i));
        debug(s, t);
        ans += t-s+1;
      }

      cout << ans << endl;
    }
};

signed main() {
  EAliceAndTheUnfairGame solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}