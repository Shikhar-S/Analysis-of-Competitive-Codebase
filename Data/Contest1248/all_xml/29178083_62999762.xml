<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="0.9.5" language="C++" filename="Data/Contest1248/all/29178083_62999762.cpp"><comment type="line">//#pragma GCC optimize ("-O3")</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bits/stdc++.h&gt;</cpp:file></cpp:include>
<using>using <namespace>namespace <name>std</name>;</namespace></using>
<comment type="line">//@èµ·åæ</comment>
<struct>struct <name>initon</name> <block>{<public type="default">
    <constructor><name>initon</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>cin</name><operator>.</operator><name>tie</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ios</name><operator>::</operator><name>sync_with_stdio</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cout</name><operator>.</operator><name>setf</name></name><argument_list>(<argument><expr><name><name>ios</name><operator>::</operator><name>fixed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cout</name><operator>.</operator><name>precision</name></name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator> <call><name>clock</name><argument_list>()</argument_list></call> <operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor><empty_stmt>;</empty_stmt>
</public>}</block> <decl><name>__initon</name></decl>;</struct>
<comment type="line">//è¡çªå¯¾ç­</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ws</name></cpp:macro> <cpp:value>___ws</cpp:value></cpp:define>
<struct>struct <name>T</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>int</name></type> <name>f</name></decl>, <decl><type ref="prev"/><name>s</name></decl>, <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
    <constructor><name>T</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>f</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>s</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>t</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> }</block></constructor>
    <constructor><name>T</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>f</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call>, <call><name>s</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>, <call><name>t</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> </member_init_list><block>{}</block></constructor>
    <function type="operator"><type><name>bool</name></type> <name>operator<name>&lt;</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>r</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{
        <return>return <expr><ternary><condition><expr><name>f</name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> ?</condition><then> <expr><name>f</name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> </then><else>: <expr><ternary><condition><expr><name>s</name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> ?</condition><then> <expr><name>s</name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> </then><else>: <expr><name>t</name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>t</name></name></expr></else></ternary></expr></else></ternary></expr>;</return>
        <comment type="line">//return f != r.f ? f &gt; r.f : s != r.s ? s &gt; r.s : t &gt; r.t; å¤§ããé </comment>
    }</block></function>
    <function type="operator"><type><name>bool</name></type> <name>operator<name>&gt;</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>r</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{
        <return>return <expr><ternary><condition><expr><name>f</name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> ?</condition><then> <expr><name>f</name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> </then><else>: <expr><ternary><condition><expr><name>s</name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> ?</condition><then> <expr><name>s</name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> </then><else>: <expr><name>t</name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>t</name></name></expr></else></ternary></expr></else></ternary></expr>;</return>
        <comment type="line">//return f != r.f ? f &gt; r.f : s != r.s ? s &gt; r.s : t &gt; r.t; å°ããé </comment>
    }</block></function>
    <function type="operator"><type><name>bool</name></type> <name>operator<name>==</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>r</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{
        <return>return <expr><name>f</name> <operator>==</operator> <name><name>r</name><operator>.</operator><name>f</name></name> <operator>&amp;&amp;</operator> <name>s</name> <operator>==</operator> <name><name>r</name><operator>.</operator><name>s</name></name> <operator>&amp;&amp;</operator> <name>t</name> <operator>==</operator> <name><name>r</name><operator>.</operator><name>t</name></name></expr>;</return>
    }</block></function>
    <function type="operator"><type><name>bool</name></type> <name>operator<name>!=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>r</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{
        <return>return <expr><name>f</name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>f</name></name> <operator>||</operator> <name>s</name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>s</name></name> <operator>||</operator> <name>t</name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>t</name></name></expr>;</return>
    }</block></function>
    <function type="operator"><type><name>int</name></type> <name>operator<name>[]</name></name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>f</name></expr> </then><else>: <expr><ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>s</name></expr> </then><else>: <expr><name>t</name></expr></else></ternary></expr></else></ternary></expr>;</return>
    }</block></function>
</public>}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>int</name></cpp:macro> <cpp:value>long long</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ll</name></cpp:macro> <cpp:value>long long</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>double</name></cpp:macro> <cpp:value>long double</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ull</name></cpp:macro> <cpp:value>unsigned long long</cpp:value></cpp:define>
<using>using <name>dou</name> <init>= <type><name>double</name></type></init>;</using>
<using>using <name>itn</name> <init>= <type><name>int</name></type></init>;</using>
<using>using <name>str</name> <init>= <type><name>string</name></type></init>;</using>
<using>using <name>bo</name><init>= <type><name>bool</name></type></init>;</using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>au</name></cpp:macro> <cpp:value>auto</cpp:value></cpp:define>
<using>using <name>P</name> <init>= <type><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name></type></init>;</using>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fi</name></cpp:macro> <cpp:value>first</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>se</name></cpp:macro> <cpp:value>second</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vec</name></cpp:macro> <cpp:value>vector</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>beg</name></cpp:macro> <cpp:value>begin</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rbeg</name></cpp:macro> <cpp:value>rbegin</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>con</name></cpp:macro> <cpp:value>continue</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bre</name></cpp:macro> <cpp:value>break</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>brk</name></cpp:macro> <cpp:value>break</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is</name></cpp:macro> <cpp:value>==</cpp:value></cpp:define>


<comment type="line">//ãã¯ã­çç¥ç³» ã³ã³ãã</comment>

<using>using <name>vi</name> <init>= <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloadvvi</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvi0</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>vec&lt;vi&gt;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvi1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vi&gt; a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvi2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vi&gt; a(b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvi3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vi&gt; a(b,vi(c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvi4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vi&gt; a(b,vi(c,d))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvi</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)</cpp:value></cpp:define>


<using>using <name>vl</name> <init>= <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloadvvl</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvl1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vl&gt; a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvl2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vl&gt; a(b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvl3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vl&gt; a(b,vl(c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvl4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vl&gt; a(b,vl(c,d))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvl</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)</cpp:value></cpp:define>

<using>using <name>vb</name> <init>= <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloadvvb</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvb1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vb&gt; a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvb2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vb&gt; a(b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvb3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vb&gt; a(b,vb(c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvb4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vb&gt; a(b,vb(c,d))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvb</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)</cpp:value></cpp:define>

<using>using <name>vs</name> <init>= <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>string</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloadvvs</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvs1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vs&gt; a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvs2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vs&gt; a(b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvs3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vs&gt; a(b,vs(c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvs4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vs&gt; a(b,vs(c,d))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvs</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)</cpp:value></cpp:define>

<using>using <name>vd</name> <init>= <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloadvvd</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvd1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vd&gt; a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvd2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vd&gt; a(b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvd3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vd&gt; a(b,vd(c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvd4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vd&gt; a(b,vd(c,d))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvd</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)</cpp:value></cpp:define>

<using>using <name>vc</name><init>=<type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloadvvc</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvc1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vc&gt; a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvc2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vc&gt; a(b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvc3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vc&gt; a(b,vc(c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvc4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vc&gt; a(b,vc(c,d))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvc</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)</cpp:value></cpp:define>

<using>using <name>vp</name> <init>= <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>P</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloadvvp</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvp1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vp&gt; a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvp2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vp&gt; a(b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvp3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vp&gt; a(b,vp(c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvp4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vp&gt; a(b,vp(c,d))</cpp:value></cpp:define>

<using>using <name>vt</name> <init>= <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloadvvt</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvt1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vt&gt; a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvt2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vt&gt; a(b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvt3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vt&gt; a(b,vt(c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvt4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vec&lt;vt&gt; a(b,vt(c,d))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>v3i</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vector&lt;vector&lt;vi&gt;&gt; a(b, vector&lt;vi&gt;(c, vi(d)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>v3d</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vector&lt;vector&lt;vd&gt;&gt; a(b, vector&lt;vd&gt;(c, vd(d)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>v3m</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vector&lt;vector&lt;vm&gt;&gt; a(b, vector&lt;vm&gt;(c, vm(d)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_vvi</name></cpp:macro> <cpp:value>vector&lt;vi&gt;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_vvl</name></cpp:macro> <cpp:value>vector&lt;vl&gt;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_vvb</name></cpp:macro> <cpp:value>vector&lt;vb&gt;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_vvs</name></cpp:macro> <cpp:value>vector&lt;vs&gt;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_vvd</name></cpp:macro> <cpp:value>vector&lt;vd&gt;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_vvc</name></cpp:macro> <cpp:value>vector&lt;vc&gt;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_vvp</name></cpp:macro> <cpp:value>vector&lt;vp&gt;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PQ</name></cpp:macro> <cpp:value>priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tos</name></cpp:macro> <cpp:value>to_string</cpp:value></cpp:define>
<using>using <name>mapi</name> <init>= <type><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<using>using <name>mapd</name> <init>= <type><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>dou</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<using>using <name>mapc</name> <init>= <type><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<using>using <name>maps</name> <init>= <type><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>str</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<using>using <name>seti</name> <init>= <type><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<using>using <name>setd</name> <init>= <type><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>dou</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<using>using <name>setc</name> <init>= <type><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<using>using <name>sets</name> <init>= <type><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>str</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<using>using <name>qui</name> <init>= <type><name><name>queue</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bset</name></cpp:macro> <cpp:value>bitset</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>uset</name></cpp:macro> <cpp:value>unordered_set</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mset</name></cpp:macro> <cpp:value>multiset</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>umap</name></cpp:macro> <cpp:value>unordered_map</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>umapi</name></cpp:macro> <cpp:value>unordered_map&lt;int,int&gt;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>umapp</name></cpp:macro> <cpp:value>unordered_map&lt;P,int&gt;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mmap</name></cpp:macro> <cpp:value>multimap</cpp:value></cpp:define>

<comment type="line">//ãã¯ã­ ç¹°ãè¿ã</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloadrep</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_rep</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for(int i = 0,_lim=n; i &lt; _lim ; i++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>repi</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>m</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for(int i = m,_lim=n; i &lt; _lim ; i++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>repadd</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>m</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>ad</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for(int i = m,_lim=n; i &lt; _lim ; i+= ad)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rep</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_rer</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for(int i = n; i &gt;= 0 ; i--)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>reri</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>m</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for(int i = m,_lim=n; i &gt;= _lim ; i--)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rerdec</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>m</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>dec</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for(int i = m,_lim=n; i &gt;= _lim ; i-=dec)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rer</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fora</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for(auto&amp;&amp; a : b)</cpp:value></cpp:define>

<comment type="line">//ãã¯ã­ å®æ°</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>k3</name></cpp:macro> <cpp:value>1010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>k4</name></cpp:macro> <cpp:value>10101</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>k5</name></cpp:macro> <cpp:value>101010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>k6</name></cpp:macro> <cpp:value>1010101</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>k7</name></cpp:macro> <cpp:value>10101010</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>inf</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <literal type="number">1e9</literal> <operator>+</operator> <literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ll</name></type> <name>linf</name> <init>= <expr><operator>(</operator><name>ll</name><operator>)</operator> <literal type="number">1e18</literal> <operator>+</operator> <literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>eps</name> <init>= <expr><literal type="number">1e-9</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>PI</name> <init>= <expr><literal type="number">3.1415926535897932384626433832795029L</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ll</name></type> <name>ma</name> <init>= <expr><call><name><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>min</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ll</name></type> <name>mi</name> <init>= <expr><call><name><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>max</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>y4</name><index>[]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>x4</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>y8</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>x8</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="line">//ãã¯ã­çç¥å½¢ é¢æ°ç­</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>arsz</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof(a)/sizeof(a[0]))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sz</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((int)(a).size())</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rs</name></cpp:macro> <cpp:value>resize</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mp</name></cpp:macro> <cpp:value>make_pair</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pb</name></cpp:macro> <cpp:value>push_back</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pf</name></cpp:macro> <cpp:value>push_front</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>eb</name></cpp:macro> <cpp:value>emplace_back</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>all</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(a).begin(),(a).end()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rall</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(a).rbegin(),(a).rend()</cpp:value></cpp:define>


<function><specifier>inline</specifier> <type><name>void</name></type> <name>sort</name><parameter_list>(<parameter><decl><type><name>string</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{ <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name><name>a</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>a</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>sort</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{ <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name><name>a</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>a</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>sort</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{ <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name><name>a</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>a</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>, <parameter><type><name>class</name></type> <name>F</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>sort</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>F</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{ <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name><name>a</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>a</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>T</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name>f</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>f</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function><empty_stmt>;</empty_stmt>
<enum>enum <name>___pcomparator</name> <block>{
    <decl><name>fisi</name></decl>, <decl><name>fisd</name></decl>, <decl><name>fdsi</name></decl>, <decl><name>fdsd</name></decl>, <decl><name>sifi</name></decl>, <decl><name>sifd</name></decl>, <decl><name>sdfi</name></decl>, <decl><name>sdfd</name></decl>
}</block>;</enum>
<function><specifier>inline</specifier> <type><name>void</name></type> <name>sort</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>P</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>___pcomparator</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
        <case>case <expr><name>fisi</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>P</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>P</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>fisd</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>P</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>P</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>fdsi</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>P</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>P</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>fdsd</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>P</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>P</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>sifi</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>P</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>P</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>sifd</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>P</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>P</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>sdfi</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>P</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>P</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>sdfd</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>P</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>P</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>se</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>se</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>fi</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>fi</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    }</block></switch>
}</block></function><empty_stmt>;</empty_stmt>
<function><specifier>inline</specifier> <type><name>void</name></type> <name>sort</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>___pcomparator</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
        <case>case <expr><name>fisi</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>T</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case
            <expr><name>fisd</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>T</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case
            <expr><name>fdsi</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>T</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case
            <expr><name>fdsd</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>T</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case
            <expr><name>sifi</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>T</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case
            <expr><name>sifd</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>T</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case
            <expr><name>sdfi</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>T</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case
            <expr><name>sdfd</name></expr>:</case>
            <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>T</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>!=</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> ?</condition><then> <expr><name><name>l</name><operator>.</operator><name>s</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>s</name></name></expr> </then><else>: <expr><name><name>l</name><operator>.</operator><name>f</name></name> <operator>&gt;</operator> <name><name>r</name><operator>.</operator><name>f</name></name></expr></else></ternary></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    }</block></switch>
}</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>rsort</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{ <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name><name>a</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>a</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>greater</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>rsort</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{ <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name><name>a</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>a</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><call><name><name>greater</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>U</name></parameter>, <parameter><type><name>class</name></type> <name>F</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>rsort</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>F</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{ <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name><name>a</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>a</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>U</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>U</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name>f</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>f</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return> }</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>sortp</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>vp</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sz</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>sz</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro><expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>eb</name></name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>second</name></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
    }</block>
}</block></function><empty_stmt>;</empty_stmt>
<comment type="line">//F = T&lt;T&gt;</comment>
<comment type="line">//ä¾ãã°return p.fi + p.se;</comment>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>U</name></parameter>, <parameter><type><name>class</name></type> <name>F</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>sortp</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>F</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>vp</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sz</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>sz</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro><expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>eb</name></name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>second</name></expr>;</expr_stmt>
    }</block>
}</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>U</name></parameter>, <parameter><type><name>class</name></type> <name>F</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>sortp</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>vp</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sz</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>sz</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro><expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>eb</name></name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>second</name></expr>;</expr_stmt>
    }</block>
}</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>rsortp</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>vp</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sz</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>sz</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro><expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>eb</name></name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rsort</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>second</name></expr>;</expr_stmt>
    }</block>
}</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>U</name></parameter>, <parameter><type><name>class</name></type> <name>F</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>rsortp</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>F</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>vp</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sz</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>sz</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro><expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>eb</name></name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rsort</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>second</name></expr>;</expr_stmt>
    }</block>
}</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>sortt</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>vt</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sz</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>sz</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>sz</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro><expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>eb</name></name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>r</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>r</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>s</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>r</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>t</name></expr>;</expr_stmt>
    }</block>
}</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>U</name></parameter>, <parameter><type><name>class</name></type> <name>F</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>sortt</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>F</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>vt</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sz</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>sz</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>sz</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro><expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>eb</name></name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>r</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>r</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>s</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>r</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>t</name></expr>;</expr_stmt>
    }</block>
}</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>U</name></parameter>, <parameter><type><name>class</name></type> <name>F</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>rsortt</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>F</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>vt</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sz</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>sz</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>sz</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro><expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>eb</name></name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rsort</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>r</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>r</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>s</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>r</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>t</name></expr>;</expr_stmt>
    }</block>
}</block></function><empty_stmt>;</empty_stmt>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>sort2</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{ <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name><name>a</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></for> }</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>void</name></type> <name>rsort2</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{ <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name><name>a</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><expr_stmt><expr><call><name>rsort</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></for> }</block></function>
<decl_stmt><decl><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>A</name></parameter>, <parameter><type><name>size_t</name></type> <name>N</name></parameter>, <parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>void</name></type> <name>fill</name><argument_list>(<argument><expr><call><name>A</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <name>T</name> <operator>&amp;</operator><name>v</name></expr></argument>)</argument_list> <argument_list>{ <argument><expr><macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>N</argument>)</argument_list></macro><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr></argument>; }</argument_list>
template<name/>&lt;<name><typename>typename</typename> <name>A</name></name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>N</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>O</name></decl>, <decl><type ref="prev"/><name><typename>typename</typename> <name>T</name></name>&gt; <name>void</name> <name>fill</name><argument_list>(<argument><expr><call><name>A</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index><index>[<expr><name>O</name></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <name>T</name> <operator>&amp;</operator><name>v</name></expr></argument>)</argument_list> <argument_list>{ <argument><expr><macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>N</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>j</argument>, <argument>O</argument>)</argument_list></macro><name><name>a</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr></argument>; }</argument_list>
template<name/>&lt;<name><typename>typename</typename> <name>A</name></name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>N</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>O</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>P</name></decl>, <decl><type ref="prev"/><name><typename>typename</typename> <name>T</name></name>&gt; <name>void</name> <name>fill</name><argument_list>(<argument><expr><call><name>A</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index><index>[<expr><name>O</name></expr>]</index><index>[<expr><name>P</name></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <name>T</name> <operator>&amp;</operator><name>v</name></expr></argument>)</argument_list> <argument_list>{ <argument><expr><macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>N</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>j</argument>, <argument>O</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>k</argument>, <argument>P</argument>)</argument_list></macro><name><name>a</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr></argument>; }</argument_list>
template<name/>&lt;<name><typename>typename</typename> <name>A</name></name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>N</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>O</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>P</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>Q</name></decl>, <decl><type ref="prev"/><name><typename>typename</typename> <name>T</name></name>&gt; <name>void</name> <name>fill</name><argument_list>(<argument><expr><call><name>A</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index><index>[<expr><name>O</name></expr>]</index><index>[<expr><name>P</name></expr>]</index><index>[<expr><name>Q</name></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <name>T</name> <operator>&amp;</operator><name>v</name></expr></argument>)</argument_list> <argument_list>{ <argument><expr><macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>N</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>j</argument>, <argument>O</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>k</argument>, <argument>P</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>l</argument>, <argument>Q</argument>)</argument_list></macro><name><name>a</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr></argument>; }</argument_list>
template<name/>&lt;<name><typename>typename</typename> <name>A</name></name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>N</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>O</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>P</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>Q</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>R</name></decl>, <decl><type ref="prev"/><name><typename>typename</typename> <name>T</name></name>&gt; <name>void</name> <name>fill</name><argument_list>(<argument><expr><call><name>A</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index><index>[<expr><name>O</name></expr>]</index><index>[<expr><name>P</name></expr>]</index><index>[<expr><name>Q</name></expr>]</index><index>[<expr><name>R</name></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <name>T</name> <operator>&amp;</operator><name>v</name></expr></argument>)</argument_list> <argument_list>{ <argument><expr><macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>N</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>j</argument>, <argument>O</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>k</argument>, <argument>P</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>l</argument>, <argument>Q</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>m</argument>, <argument>R</argument>)</argument_list></macro><name><name>a</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>l</name></expr>]</index><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr></argument>; }</argument_list>
template<name/>&lt;<name><typename>typename</typename> <name>A</name></name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>N</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>O</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>P</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>Q</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>R</name></decl>, <decl><type ref="prev"/><name>size_t</name> <name>S</name></decl>, <decl><type ref="prev"/><name><typename>typename</typename> <name>T</name></name>&gt; <name>void</name> <name>fill</name><argument_list>(<argument><expr><call><name>A</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index><index>[<expr><name>O</name></expr>]</index><index>[<expr><name>P</name></expr>]</index><index>[<expr><name>Q</name></expr>]</index><index>[<expr><name>R</name></expr>]</index><index>[<expr><name>S</name></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <name>T</name> <operator>&amp;</operator><name>v</name></expr></argument>)</argument_list> <argument_list>{ <argument><expr><macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>N</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>j</argument>, <argument>O</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>k</argument>, <argument>P</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>l</argument>, <argument>Q</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>m</argument>, <argument>R</argument>)</argument_list></macro><macro><name>rep</name><argument_list>(<argument>n</argument>, <argument>S</argument>)</argument_list></macro><name><name>a</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>l</name></expr>]</index><index>[<expr><name>m</name></expr>]</index><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr></argument>; }</argument_list>

template<name/>&lt;<name><typename>typename</typename> <name>V</name></name></decl>, <decl><type ref="prev"/><name><typename>typename</typename> <name>T</name></name>&gt;
<name>void</name> <name>fill</name><argument_list>(<argument><expr><name>V</name> <operator>&amp;</operator><name>xx</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>T</name> <name>vall</name></expr></argument>)</argument_list> <argument_list>{
    <argument><expr><name>xx</name> <operator>=</operator> <name>vall</name></expr></argument>;
}</argument_list>
template<name/>&lt;<name><typename>typename</typename> <name>V</name></name></decl>, <decl><type ref="prev"/><name><typename>typename</typename> <name>T</name></name>&gt;
<name>void</name> <name>fill</name><argument_list>(<argument><expr><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>V</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>vecc</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>T</name> <name>vall</name></expr></argument>)</argument_list> <argument_list>{
    for <argument><expr><operator>(</operator><name>auto</name> <operator>&amp;&amp;</operator><name>vx</name><operator>:</operator> <name>vecc</name><operator>)</operator> <call><name>fill</name><argument_list>(<argument><expr><name>vx</name></expr></argument>, <argument><expr><name>vall</name></expr></argument>)</argument_list></call></expr></argument>;
}</argument_list>

<comment type="line">//@æ±ç¨ä¾¿å©é¢æ° å¥å</comment>
template<name/>&lt;<name><typename>typename</typename> <name>T</name></name> <init>= <expr><name>int</name><operator>&gt;</operator> <name>T</name> <macro><name>_in</name><argument_list>()</argument_list></macro> <block>{
    <expr><name>T</name> <name>x</name></expr>;
    <expr><name>cin</name> <operator>&gt;&gt;</operator> <name>x</name></expr>;
    <return>return <expr><operator>(</operator><name>x</name><operator>)</operator></expr>;</return>
}</block></expr></init></decl></decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloadin</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>in0</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>_in()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>in1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cin&gt;&gt;a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>in2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cin&gt;&gt;a&gt;&gt;b</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>in3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>in4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>in</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloaddin</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>din1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>int a;cin&gt;&gt;a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>din2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>int a,b;cin&gt;&gt;a&gt;&gt;b</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>din3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>din4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>int a,b,c,d;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>din</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloaddind</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>din1d</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>int a;cin&gt;&gt;a;a--</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>din2d</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>int a,b;cin&gt;&gt;a&gt;&gt;b;a--,b--</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>din3d</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;a--,b--,c--</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>din4d</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>int a,b,c,d;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;;a--,b--,c--,d--</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dind</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)</cpp:value></cpp:define>


<function><type><name>string</name></type> <name>sin</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>_in</name><argument_list type="generic">&lt;<argument><expr><name>string</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
<function><type><name>ll</name></type> <name>lin</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>_in</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>na</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a.resize(n); rep(i,n) cin &gt;&gt; a[i];</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nao</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a.resize(n+1); rep(i,n) cin &gt;&gt; a[i+1];</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nad</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a.resize(n); rep(i,n){ cin &gt;&gt; a[i]; a[i]--;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>na2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a.resize(n),b.resize(n);rep(i, n)cin &gt;&gt; a[i] &gt;&gt; b[i];</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>na2d</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a.resize(n),b.resize(n);rep(i, n){cin &gt;&gt; a[i] &gt;&gt; b[i];a[i]--,b[i]--;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>na3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>na3d</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];a[i]--,b[i]--,c[i]--;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nt</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>h</name></type></parameter>, <parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>resize(a,h,w);rep(hi,h)rep(wi,w) cin &gt;&gt; a[hi][wi];</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ntd</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>h</name></type></parameter>, <parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rs(a,h,w);rep(hi,h)rep(wi,w) cin &gt;&gt; a[hi][wi], a[hi][wi]--;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ntp</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>h</name></type></parameter>, <parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin &gt;&gt; a[hi][wi];</cpp:value></cpp:define>

<comment type="line">//ãããã°</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sp</name></cpp:macro> <cpp:value>&lt;&lt; " " &lt;&lt;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugName</name><parameter_list>(<parameter><type><name>VariableName</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value># VariableName</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_deb1</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cerr &lt;&lt;  debugName(x)&lt;&lt;" = "&lt;&lt;x &lt;&lt; endl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_deb2</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cerr &lt;&lt;  debugName(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;", "&lt;&lt; debugName(y)&lt;&lt;" = "&lt;&lt;y&lt;&lt; endl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_deb3</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cerr &lt;&lt;  debugName(x)&lt;&lt;" = "&lt;&lt;x  &lt;&lt; ", " &lt;&lt;  debugName(y)&lt;&lt;" = "&lt;&lt;y &lt;&lt;", " debugName(z)&lt;&lt;" = "&lt;&lt;z &lt;&lt;endl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_deb4</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>, <parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cerr &lt;&lt;  debugName(x)&lt;&lt;" = "&lt;&lt;x &lt;&lt;", " &lt;&lt;   debugName(y)&lt;&lt;" = "&lt;&lt;y &lt;&lt;", " &lt;&lt;  debugName(z)&lt;&lt;" = "&lt;&lt;z &lt;&lt;", " &lt;&lt;  debugName(a)&lt;&lt;" = "&lt;&lt;a&lt;&lt;endl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_deb5</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cerr &lt;&lt;  debugName(x)&lt;&lt;" = "&lt;&lt;x &lt;&lt;", " &lt;&lt;   debugName(y)&lt;&lt;" = "&lt;&lt;y &lt;&lt;", " &lt;&lt;  debugName(z)&lt;&lt;" = "&lt;&lt;z &lt;&lt;", " &lt;&lt;  debugName(a)&lt;&lt;" = "&lt;&lt;a&lt;&lt;", " &lt;&lt;  debugName(b)&lt;&lt;" = "&lt;&lt;b&lt;&lt;endl</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_overloadebug</name><parameter_list>(<parameter><type><name>_1</name></type></parameter>, <parameter><type><name>_2</name></type></parameter>, <parameter><type><name>_3</name></type></parameter>, <parameter><type><name>_4</name></type></parameter>, <parameter><type><name>_5</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>deb</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debugline</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cerr &lt;&lt; x &lt;&lt; " " &lt;&lt; "(L:" &lt;&lt; __LINE__ &lt;&lt; ")" &lt;&lt; '\n'</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>ole</name><parameter_list>()</parameter_list> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>debugline</name><argument_list>(<argument><expr><literal type="string">"ole"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>string</name></type> <name>a</name> <init>= <expr><literal type="string">"a"</literal></expr></init></decl>;</decl_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument><literal type="number">30</literal></argument>)</argument_list></macro><expr_stmt><expr><name>a</name> <operator>+=</operator> <name>a</name></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument><literal type="number">1</literal> &lt;&lt; <literal type="number">17</literal></argument>)</argument_list></macro><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <name>a</name> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"OLE åºåé·å¶éè¶é"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>tle</name><parameter_list>()</parameter_list> <block>{ <while>while <condition>(<expr><name>inf</name></expr>)</condition><block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <name>inf</name> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></while> }</block></function>
<function><type><name>ll</name></type> <name>gcd</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name>b</name></expr> ?</condition><then> <expr><call><name>gcd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name> <operator>%</operator> <name>b</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>a</name></expr></else></ternary></expr>;</return> }</block></function>
<function><type><name>ll</name></type> <name>gcd</name><parameter_list>(<parameter><decl><type><name>vi</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>ll</name></type> <name>res</name> <init>= <expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>auto</name> <operator>&amp;&amp;</operator><name>v</name> <operator>:</operator><name>b</name></expr></init>)</control><block type="pseudo"><expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>gcd</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></for>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><type><name>ll</name></type> <name>lcm</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>a</name> <operator>/</operator> <call><name>gcd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>b</name></expr>;</return> }</block></function>
<function><type><name>ll</name></type> <name>rev</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>ll</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>a</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>res</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>+=</operator> <name>a</name> <operator>%</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>a</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>void</name></type> <name>rev</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>reverse</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>rev</name><parameter_list>(<parameter><decl><type><name>string</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>reverse</name><argument_list>(<argument><expr><call><name>all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>ll</name></type> <name>ceil</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>debugline</name><argument_list>(<argument><expr><literal type="string">"ceil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>deb</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ole</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></then> <else>else <block type="pseudo"><return>return <expr><operator>(</operator><name>a</name> <operator>+</operator> <name>b</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>b</name></expr>;</return></block></else></if>
}</block></function>
<function><type><name>ll</name></type> <name>sqrt</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>debugline</name><argument_list>(<argument><expr><literal type="string">"sqrt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>deb</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ole</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <decl_stmt><decl><type><name>ll</name></type> <name>res</name> <init>= <expr><operator>(</operator><name>ll</name><operator>)</operator> <call><name><name>std</name><operator>::</operator><name>sqrt</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>res</name> <operator>*</operator> <name>res</name> <operator>&lt;</operator> <name>a</name></expr>)</condition><block type="pseudo"><expr_stmt><expr><name>res</name><operator>++</operator></expr>;</expr_stmt></block></while>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><type><name>double</name></type> <name>log</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name>log</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>log</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><type><name>ll</name></type> <name>sig</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>t</name><operator>)</operator> <operator>*</operator> <name>t</name> <operator>/</operator> <literal type="number">2</literal></expr>;</return> }</block></function>
<function><type><name>ll</name></type> <name>sig</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>(</operator><name>s</name> <operator>+</operator> <name>t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>t</name> <operator>-</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</return> }</block></function>

<function><type><name>vi</name></type> <name>divisors</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>vi</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>lim</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>sqrt</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>lim</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
        <if>if <condition>(<expr><name>v</name> <operator>%</operator> <name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>res</name><operator>.</operator><name>pb</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>v</name> <operator>/</operator> <name>i</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><call><name><name>res</name><operator>.</operator><name>pb</name></name><argument_list>(<argument><expr><name>v</name> <operator>/</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
        }</block></then></if>
    }</block></for>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>vb</name></type> <name>isPrime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>vi</name></type> <name>primes</name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>setPrime</name><parameter_list>()</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">4010101</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>isPrime</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><literal type="number">4010101</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fill</name><argument_list>(<argument><expr><name>isPrime</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>isPrime</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>isPrime</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
        <if>if <condition>(<expr><operator>!</operator><name><name>isPrime</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then><block type="pseudo"><continue>continue;</continue></block></then></if>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>*</operator> <name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{
            <expr_stmt><expr><name><name>isPrime</name><index>[<expr><name>i</name> <operator>*</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        }</block></for>
    }</block></for>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>len</argument>)</argument_list></macro><if>if <condition>(<expr><name><name>isPrime</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><call><name><name>primes</name><operator>.</operator><name>pb</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
}</block></function>

<function><type><name>vi</name></type> <name>factorization</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>tv</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>vi</name></type> <name>res</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>isPrime</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><call><name>setPrime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block></then></if>
    <for>for <control>(<init><expr><name>auto</name> <operator>&amp;&amp;</operator><name>p</name> <operator>:</operator><name>primes</name></expr></init>)</control> <block>{
        <if>if <condition>(<expr><name>v</name> <operator>%</operator> <name>p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><call><name><name>res</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
        <while>while <condition>(<expr><name>v</name> <operator>%</operator> <name>p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{
            <expr_stmt><expr><name>v</name> <operator>/=</operator> <name>p</name></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>v</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>p</name> <operator>*</operator> <name>p</name> <operator>&gt;</operator> <name>tv</name></expr>)</condition><then><block type="pseudo"><break>break;</break></block></then></if>
    }</block></for>
    <if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><call><name><name>res</name><operator>.</operator><name>pb</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><specifier>inline</specifier> <type><name>bool</name></type> <name>inside</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>H</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>W</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>h</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>w</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>h</name> <operator>&lt;</operator> <name>H</name> <operator>&amp;&amp;</operator> <name>w</name> <operator>&lt;</operator> <name>W</name></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>bool</name></type> <name>inside</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>l</name> <operator>&lt;=</operator> <name>v</name> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;</operator> <name>r</name></expr>;</return> }</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ins</name></cpp:macro> <cpp:value>inside</cpp:value></cpp:define>
<function><type><name>ll</name></type> <name>u</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><ternary><condition><expr><name>a</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>a</name></expr></else></ternary></expr>;</return> }</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>u</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>ret</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>
    <macro><name>fora</name><argument_list>(<argument>v</argument>, <argument>ret</argument>)</argument_list></macro><expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>u</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>numeric_limits&lt;a&gt;::min()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>numeric_limits&lt;a&gt;::max()</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>yn</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>a</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"yes"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></then>
    <else>else <block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"no"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></else></if>
}</block></function>
<function><type><name>void</name></type> <name>Yn</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>a</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"Yes"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></then>
    <else>else <block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"No"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></else></if>
}</block></function>
<function><type><name>void</name></type> <name>YN</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>a</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"YES"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></then>
    <else>else <block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"NO"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></else></if>
}</block></function>
<function><type><name>void</name></type> <name>fyn</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>a</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"yes"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></then>
    <else>else <block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"no"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></else></if>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>fYn</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>a</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"Yes"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></then>
    <else>else <block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"No"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></else></if>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>fYN</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>a</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"YES"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></then>
    <else>else <block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"NO"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></else></if>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>Possible</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>a</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"Possible"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></then>
    <else>else <block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"Impossible"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></else></if>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>POSSIBLE</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>a</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"POSSIBLE"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></then>
    <else>else <block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <literal type="string">"IMPOSSIBLE"</literal> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt></block></else></if>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>, <parameter><type><name>class</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>operator<name>+=</name></name><parameter_list>(<parameter><decl><type><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>U</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{
    <expr_stmt><expr><call><name><name>a</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>a</name></expr>;</return>
}</block></function>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>, <parameter><type><name>class</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>operator<name>+=</name></name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>U</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{
    <expr_stmt><expr><call><name><name>a</name><operator>.</operator><name>pb</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>a</name></expr>;</return>
}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>T</name></type> <name>sum</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>s</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t</name> <init>= <expr><name>inf</name></expr></init></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>T</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>s</argument>, <argument>min(sz(v), t)</argument>)</argument_list></macro><expr_stmt><expr><name>ret</name> <operator>+=</operator> <name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>mod</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>m</name></decl></parameter>)</parameter_list> <block>{ <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>a</name> <operator>%</operator> <name>m</name> <operator>+</operator> <name>m</name><operator>)</operator> <operator>%</operator> <name>m</name></expr>;</expr_stmt> }</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>F</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>int</name></type> <name>mgr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ok</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ng</name></decl></parameter>, <parameter><decl><type><name>F</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_mgrbody</name></cpp:macro> <cpp:value>int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;</cpp:value></cpp:define>
    <if>if <condition>(<expr><name>ok</name> <operator>&lt;</operator> <name>ng</name></expr>)</condition><then><block type="pseudo"><while>while <condition>(<expr><name>ng</name> <operator>-</operator> <name>ok</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{ <expr_stmt><expr><name>_mgrbody</name></expr></expr_stmt> }</block></while></block></then> <else>else <block type="pseudo"><while>while <condition>(<expr><name>ok</name> <operator>-</operator> <name>ng</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{ <expr_stmt><expr><name>_mgrbody</name></expr></expr_stmt> }</block></while></block></else></if>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>F</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>int</name></type> <name>mgr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ok</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ng</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>second</name></decl></parameter>, <parameter><decl><type><name>F</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_mgrbody2</name></cpp:macro> <cpp:value>int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;</cpp:value></cpp:define>
    <if>if <condition>(<expr><name>ok</name> <operator>&lt;</operator> <name>ng</name></expr>)</condition><then> <block type="pseudo"><while>while <condition>(<expr><name>ng</name> <operator>-</operator> <name>ok</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{ <expr_stmt><expr><name>_mgrbody2</name></expr></expr_stmt> }</block></while></block></then> <else>else <block type="pseudo"><while>while <condition>(<expr><name>ok</name> <operator>-</operator> <name>ng</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{ <expr_stmt><expr><name>_mgrbody2</name></expr></expr_stmt> }</block></while></block></else></if>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>ostream</name> <modifier>&amp;</modifier></type><name>operator<name>&lt;&lt;</name></name><parameter_list>(<parameter><decl><type><name>ostream</name> <modifier>&amp;</modifier></type><name>os</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>m</name></decl></parameter>)</parameter_list> <block>{
    <for>for <control>(<init><expr><name>auto</name> <operator>&amp;&amp;</operator><name>v</name><operator>:</operator><name>m</name></expr></init>)</control> <block type="pseudo"><expr_stmt><expr><name>os</name> <operator>&lt;&lt;</operator> <name>v</name> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;</expr_stmt></block></for>
    <return>return <expr><name>os</name></expr>;</return>
}</block></function>
<function><specifier>constexpr</specifier> <type><name>bool</name></type> <name>bget</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keta</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>(</operator><name>m</name> <operator>&gt;&gt;</operator> <name>keta</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</return> }</block></function>
<function><type><name>int</name></type> <name>bget</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keta</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sinsuu</name></decl></parameter>)</parameter_list> <block>{
    <expr_stmt><expr><name>m</name> <operator>/=</operator> <operator>(</operator><name>ll</name><operator>)</operator> <call><name>pow</name><argument_list>(<argument><expr><name>sinsuu</name></expr></argument>, <argument><expr><name>keta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>m</name> <operator>%</operator> <name>sinsuu</name></expr>;</return>
}</block></function>
<function><type><name>ll</name></type> <name>bit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>(</operator><literal type="number">1LL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>n</name><operator>)</operator><operator>)</operator></expr>;</return> }</block></function>
<function><type><name>ll</name></type> <name>bit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sinsuu</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>(</operator><name>ll</name><operator>)</operator> <call><name>pow</name><argument_list>(<argument><expr><name>sinsuu</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><type><name>int</name></type> <name>mask</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>(</operator><literal type="number">1ll</literal> <operator>&lt;&lt;</operator> <name>n</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</return> }</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bcou</name></cpp:macro> <cpp:value>__builtin_popcountll</cpp:value></cpp:define>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>ruiv</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>ret</name><argument_list>(<argument><expr><call><name><name>a</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument>a.size()</argument>)</argument_list></macro><expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>, <parameter><type><name>class</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>bool</name></type> <name>chma</name><parameter_list>(<parameter><decl><type><name>T</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U</name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></then></if>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>bool</name></type> <name>chma</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>U</name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name>chma</name><argument_list>(<argument><expr><name>ma</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>, <parameter><type><name>class</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>bool</name></type> <name>chmi</name><parameter_list>(<parameter><decl><type><name>T</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U</name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <name>a</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></then></if>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>bool</name></type> <name>chmi</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>U</name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name>chmi</name><argument_list>(<argument><expr><name>mi</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unique</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>v.erase( unique(v.begin(), v.end()), v.end() );</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>max</name><parameter_list>(<parameter><decl><type><name>vi</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <macro><name>fora</name><argument_list>(<argument>v</argument>, <argument>a</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>max</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>min</name><parameter_list>(<parameter><decl><type><name>vi</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <macro><name>fora</name><argument_list>(<argument>v</argument>, <argument>a</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>min</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>d</name></decl>, <decl><type ref="prev"/><name>H</name></decl>, <decl><type ref="prev"/><name>W</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>z</name></decl>, <decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cou</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>vi</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>vvi</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vvc</name> <argument_list>(<argument><expr><name>ba</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>vp</name></type> <name>p</name></decl>;</decl_stmt>
<comment type="line">//@formatter:off</comment>
<function_decl><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>T</name></type> <name>minv</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>m</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>T</name></type> <name>minv</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>a</name></decl></parameter>)</parameter_list>;</function_decl>

<class><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
class <name>Modular</name> <block>{<private type="default">
</private><public>public:
    <using>using <name>Type</name> <init>= <type><name><typename>typename</typename> <name><name>decay</name><argument_list type="generic">&lt;<argument><expr><decltype>decltype<argument_list>(<argument><expr><name><name>T</name><operator>::</operator><name>value</name></name></expr></argument>)</argument_list></decltype></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></name></type></init>;</using>    <constructor><specifier>constexpr</specifier> <name>Modular</name><parameter_list>()</parameter_list> <member_init_list>: <call><name>value</name><argument_list>()</argument_list></call> </member_init_list><block>{}</block></constructor>    <constructor><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template>    <name>Modular</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>U</name> <modifier>&amp;</modifier></type><name>x</name></decl></parameter>)</parameter_list> <block>{        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>normalize</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    }</block></constructor>    <function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template>    <specifier>static</specifier> <type><name>Type</name></type> <name>normalize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>U</name> <modifier>&amp;</modifier></type><name>x</name></decl></parameter>)</parameter_list> <block>{        <decl_stmt><decl><type><name>Type</name></type> <name>v</name></decl>;</decl_stmt>        <if>if <condition>(<expr><operator>-</operator><call><name>mod</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>x</name> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <call><name>mod</name><argument_list>()</argument_list></call></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>v</name> <operator>=</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></cast></expr>;</expr_stmt></block></then>        <else>else <block type="pseudo"><expr_stmt><expr><name>v</name> <operator>=</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>x</name> <operator>%</operator> <call><name>mod</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></cast></expr>;</expr_stmt></block></else></if>        <if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>v</name> <operator>+=</operator> <call><name>mod</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block></then></if>        <return>return <expr><name>v</name></expr>;</return>    }</block></function>    <function type="operator"><type><specifier>const</specifier> <name>Type</name> <modifier>&amp;</modifier></type><name>operator<name>()</name></name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><name>value</name></expr>;</return> }</block></function>    <function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template><specifier>explicit</specifier> <name>operator <name>U</name></name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></cast></expr>;</return> }</block></function>    <function><specifier>constexpr</specifier> <specifier>static</specifier> <type><name>Type</name></type> <name>mod</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name><name>T</name><operator>::</operator><name>value</name></name></expr>;</return> }</block></function>    <function type="operator"><type><name>Modular</name> <modifier>&amp;</modifier></type><name>operator<name>+=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Modular</name> <modifier>&amp;</modifier></type><name>other</name></decl></parameter>)</parameter_list> <block>{        <if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>+=</operator> <name><name>other</name><operator>.</operator><name>value</name></name><operator>)</operator> <operator>&gt;=</operator> <call><name>mod</name><argument_list>()</argument_list></call></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>value</name> <operator>-=</operator> <call><name>mod</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block></then></if>        <return>return <expr><operator>*</operator><name>this</name></expr>;</return>    }</block></function>    <function type="operator"><type><name>Modular</name> <modifier>&amp;</modifier></type><name>operator<name>-=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Modular</name> <modifier>&amp;</modifier></type><name>other</name></decl></parameter>)</parameter_list> <block>{        <if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>-=</operator> <name><name>other</name><operator>.</operator><name>value</name></name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>value</name> <operator>+=</operator> <call><name>mod</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block></then></if>        <return>return <expr><operator>*</operator><name>this</name></expr>;</return>    }</block></function>    <function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name>Modular</name> <modifier>&amp;</modifier></type><name>operator<name>+=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>U</name> <modifier>&amp;</modifier></type><name>other</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>*</operator><name>this</name> <operator>+=</operator> <call><name>Modular</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>    <function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name>Modular</name> <modifier>&amp;</modifier></type><name>operator<name>-=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>U</name> <modifier>&amp;</modifier></type><name>other</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>*</operator><name>this</name> <operator>-=</operator> <call><name>Modular</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>    <function type="operator"><type><name>Modular</name> <modifier>&amp;</modifier></type><name>operator<name>++</name></name><parameter_list>()</parameter_list> <block>{ <return>return <expr><operator>*</operator><name>this</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</return> }</block></function>    <function type="operator"><type><name>Modular</name> <modifier>&amp;</modifier></type><name>operator<name>--</name></name><parameter_list>()</parameter_list> <block>{ <return>return <expr><operator>*</operator><name>this</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</return> }</block></function>    <function type="operator"><type><name>Modular</name></type> <name>operator<name>++</name></name><parameter_list>(<parameter><decl><type><name>signed</name></type></decl></parameter>)</parameter_list> <block>{        <decl_stmt><decl><type><name>Modular</name></type> <name>result</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></decl>;</decl_stmt>        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>        <return>return <expr><name>result</name></expr>;</return>    }</block></function>    <function type="operator"><type><name>Modular</name></type> <name>operator<name>--</name></name><parameter_list>(<parameter><decl><type><name>signed</name></type></decl></parameter>)</parameter_list> <block>{        <decl_stmt><decl><type><name>Modular</name></type> <name>result</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></decl>;</decl_stmt>        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>        <return>return <expr><name>result</name></expr>;</return>    }</block></function>    <function type="operator"><type><name>Modular</name></type> <name>operator<name>-</name></name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><call><name>Modular</name><argument_list>(<argument><expr><operator>-</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
    <function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>U</name> <init>= <expr><name>T</name></expr></init></parameter>&gt;</parameter_list></template><type><name><typename>typename</typename> <name><name>enable_if</name><argument_list type="generic">&lt;<argument><expr><name><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name><typename>typename</typename> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Type</name></name></expr></argument>, <argument><expr><name>signed</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></name></expr></argument>, <argument><expr><name>Modular</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></name> <modifier>&amp;</modifier></type><name>operator<name>*=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Modular</name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name> <init>= <expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></cast> <operator>*</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name><name>rhs</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></cast></expr></init></decl>;</decl_stmt><decl_stmt><decl><type><name>uint32_t</name></type> <name>xh</name> <init>= <expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></cast></expr></init></decl>, <decl><type ref="prev"/><name>xl</name> <init>= <expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></cast></expr></init></decl>, <decl><type ref="prev"/><name>d</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt><asm>asm("divl %4; \n\t": "=a" (d), "=d" (m): "d" (xh), "a" (xl), "r" (mod()));</asm><expr_stmt><expr><name>value</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>normalize</name><argument_list>(<argument><expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></cast> <operator>*</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name><name>rhs</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></cast></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><operator>*</operator><name>this</name></expr>;</return>
    }</block></function>
    <function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>U</name> <init>= <expr><name>T</name></expr></init></parameter>&gt;</parameter_list></template>    <type><name><typename>typename</typename> <name><name>enable_if</name><argument_list type="generic">&lt;<argument><expr><name><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name><typename>typename</typename> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Type</name></name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></name></expr></argument>, <argument><expr><name>Modular</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></name> <modifier>&amp;</modifier></type><name>operator<name>*=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Modular</name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{        <decl_stmt><decl><type><name>int64_t</name></type> <name>q</name> <init>= <expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></cast> <operator>*</operator> <name><name>rhs</name><operator>.</operator><name>value</name></name> <operator>/</operator> <call><name>mod</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></cast></expr></init></decl>;</decl_stmt>        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>normalize</name><argument_list>(<argument><expr><name>value</name> <operator>*</operator> <name><name>rhs</name><operator>.</operator><name>value</name></name> <operator>-</operator> <name>q</name> <operator>*</operator> <call><name>mod</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <return>return <expr><operator>*</operator><name>this</name></expr>;</return>    }</block></function>    <function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>U</name> <init>= <expr><name>T</name></expr></init></parameter>&gt;</parameter_list></template>    <type><name><typename>typename</typename> <name><name>enable_if</name><argument_list type="generic">&lt;<argument><expr><operator>!</operator><name><name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name><typename>typename</typename> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Type</name></name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></name></expr></argument>, <argument><expr><name>Modular</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></name> <modifier>&amp;</modifier></type><name>operator<name>*=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Modular</name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>normalize</name><argument_list>(<argument><expr><name>value</name> <operator>*</operator> <name><name>rhs</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <return>return <expr><operator>*</operator><name>this</name></expr>;</return>    }</block></function>    <function type="operator"><type><name>Modular</name> <modifier>&amp;</modifier></type><name>operator<name>/=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Modular</name> <modifier>&amp;</modifier></type><name>other</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>*</operator><name>this</name> <operator>*=</operator> <call><name>Modular</name><argument_list>(<argument><expr><call><name>minv</name><argument_list>(<argument><expr><name><name>other</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>    <template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list> <friend>friend <function_decl type="operator"><type><name>bool</name></type> <name>operator<name>==</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list>;</function_decl></friend></template>    <template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list> <friend>friend <function_decl type="operator"><type><name>bool</name></type> <name>operator<name>&lt;</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list>;</function_decl></friend></template>    <template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list> <friend>friend <function_decl type="operator"><type><name><name>std</name><operator>::</operator><name>istream</name></name> <modifier>&amp;</modifier></type><name>operator<name>&gt;&gt;</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>istream</name></name> <modifier>&amp;</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>number</name></decl></parameter>)</parameter_list>;</function_decl></friend></template>    <function type="operator"><name>operator <name>int</name></name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>value</name></expr>;</return> }</block></function></public><private>private:    <decl_stmt><decl><type><name>Type</name></type> <name>value</name></decl>;</decl_stmt>
</private>}</block>;</class>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>bool</name></type> <name>operator<name>==</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name><name>lhs</name><operator>.</operator><name>value</name></name> <operator>==</operator> <name><name>rhs</name><operator>.</operator><name>value</name></name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name>bool</name></type> <name>operator<name>==</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><name>U</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name>lhs</name> <operator>==</operator> <call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name>bool</name></type> <name>operator<name>==</name></name><parameter_list>(<parameter><decl><type><name>U</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>bool</name></type> <name>operator<name>!=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>!</operator><operator>(</operator><name>lhs</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name>bool</name></type> <name>operator<name>!=</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><name>U</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>!</operator><operator>(</operator><name>lhs</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name>bool</name></type> <name>operator<name>!=</name></name><parameter_list>(<parameter><decl><type><name>U</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><operator>!</operator><operator>(</operator><name>lhs</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>bool</name></type> <name>operator<name>&lt;</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><name><name>lhs</name><operator>.</operator><name>value</name></name> <operator>&lt;</operator> <name><name>rhs</name><operator>.</operator><name>value</name></name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>+</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>+</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><name>U</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>+</name></name><parameter_list>(<parameter><decl><type><name>U</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>-</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>-=</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>-</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><name>U</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>-=</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>-</name></name><parameter_list>(<parameter><decl><type><name>U</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>-=</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>*</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>*=</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>*</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><name>U</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>*=</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>*</name></name><parameter_list>(<parameter><decl><type><name>U</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>*=</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>/</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>/=</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>/</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><name>U</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>/=</operator> <name>rhs</name></expr>;</return> }</block></function><function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>operator<name>/</name></name><parameter_list>(<parameter><decl><type><name>U</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>/=</operator> <name>rhs</name></expr>;</return> }</block></function>

<decl_stmt><decl><specifier>constexpr</specifier> <type><name>signed</name></type> <name>MOD</name> <init>=
<comment type="line">//        998244353;</comment>
<expr><literal type="number">1e9</literal> <operator>+</operator> <literal type="number">7</literal></expr></init></decl>;</decl_stmt><comment type="line">//MOD</comment>
<using>using <name>mint</name> <init>= <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name><name>integral_constant</name><argument_list type="generic">&lt;<argument><expr><name><name><name>decay</name><argument_list type="generic">&lt;<argument><expr><decltype>decltype<argument_list>(<argument><expr><name>MOD</name></expr></argument>)</argument_list></decltype></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></name></expr></argument>, <argument><expr><name>MOD</name></expr></argument>&gt;</argument_list></name></name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<decl_stmt><decl><specifier>constexpr</specifier> <type><name>int</name></type> <name>mint_len</name> <init>= <expr><literal type="number">1400001</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>vi</name></type> <name>fac</name></decl>, <decl><type ref="prev"/><name>finv</name></decl>, <decl><type ref="prev"/><name>inv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>vi</name></type> <name>p2</name></decl>;</decl_stmt>
<function><type><name>mint</name></type> <name>com</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{    <if>if <condition>(<expr><name><name>r</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>r</name></expr></argument> &gt;</argument_list></name> <name>n</name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="number">0</literal></expr>;</return></block></then></if>    <return>return <expr><call><name>mint</name><argument_list>(<argument><expr><name><name>finv</name><index>[<expr><name>r</name></expr>]</index></name> <operator>*</operator> <name><name>fac</name><index>[<expr><name>n</name></expr>]</index></name> <operator>%</operator> <name>MOD</name> <operator>*</operator> <name><name>finv</name><index>[<expr><name>n</name> <operator>-</operator> <name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>}</block></function>
<function><type><name>mint</name></type> <name>pom</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<comment type="block">/*    if (!sz(fac)) com(0, -1);*/</comment>    <if>if <condition>(<expr><name><name>r</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>r</name></expr></argument> &gt;</argument_list></name> <name>n</name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="number">0</literal></expr>;</return></block></then></if>    <return>return <expr><call><name>mint</name><argument_list>(<argument><expr><name><name>fac</name><index>[<expr><name>n</name></expr>]</index></name> <operator>*</operator> <name><name>finv</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>}</block></function>
<function><type><name>mint</name></type> <name>npr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<comment type="block">/*    if (!sz(fac)) com(0, -1);*/</comment>    <if>if <condition>(<expr><name><name>r</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>r</name></expr></argument> &gt;</argument_list></name> <name>n</name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="number">0</literal></expr>;</return></block></then></if>    <return>return <expr><call><name>mint</name><argument_list>(<argument><expr><name><name>fac</name><index>[<expr><name>n</name></expr>]</index></name> <operator>*</operator> <name><name>finv</name><index>[<expr><name>n</name> <operator>-</operator> <name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>}</block></function>
<function><type><name>int</name></type> <name>nprin</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<comment type="block">/*    if (!sz(fac)) com(0, -1);*/</comment>    <if>if <condition>(<expr><name><name>r</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>r</name></expr></argument> &gt;</argument_list></name> <name>n</name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="number">0</literal></expr>;</return></block></then></if>    <return>return <expr><name><name>fac</name><index>[<expr><name>n</name></expr>]</index></name> <operator>*</operator> <name><name>finv</name><index>[<expr><name>n</name> <operator>-</operator> <name>r</name></expr>]</index></name> <operator>%</operator> <name>MOD</name></expr>;</return>}</block></function>
<function><type><name>int</name></type> <name>icom</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>NUM_</name> <init>= <expr><literal type="number">1400001</literal></expr></init></decl>;</decl_stmt>    <decl_stmt><decl><specifier>static</specifier> <type><name>ll</name></type> <name><name>fac</name><index>[<expr><name>NUM_</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>finv</name><index>[<expr><name>NUM_</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>inv</name><index>[<expr><name>NUM_</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>    <if>if <condition>(<expr><name><name>fac</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{        <expr_stmt><expr><name><name>inv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>fac</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>finv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>NUM_</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block type="pseudo"><expr_stmt><expr><name><name>inv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>inv</name><index>[<expr><name>MOD</name> <operator>%</operator> <name>i</name></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>MOD</name> <operator>-</operator> <name>MOD</name> <operator>/</operator> <name>i</name><operator>)</operator> <operator>%</operator> <name>MOD</name></expr>;</expr_stmt></block></for>        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>NUM_</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block type="pseudo"><expr_stmt><expr><name><name>fac</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>fac</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>i</name> <operator>%</operator> <name>MOD</name></expr><operator>,</operator> <expr><name><name>finv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>finv</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>inv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>%</operator> <name>MOD</name></expr>;</expr_stmt></block></for>    }</block></then></if>    <if>if <condition>(<expr><name><name>r</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>r</name></expr></argument> &gt;</argument_list></name> <name>n</name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="number">0</literal></expr>;</return></block></then></if>    <return>return <expr><operator>(</operator><operator>(</operator><name><name>finv</name><index>[<expr><name>r</name></expr>]</index></name> <operator>*</operator> <name><name>fac</name><index>[<expr><name>n</name></expr>]</index></name> <operator>%</operator> <name>MOD</name><operator>)</operator> <operator>*</operator> <name><name>finv</name><index>[<expr><name>n</name> <operator>-</operator> <name>r</name></expr>]</index></name><operator>)</operator> <operator>%</operator> <name>MOD</name></expr>;</return>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ncr</name></cpp:macro> <cpp:value>com</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ncri</name></cpp:macro> <cpp:value>icom</cpp:value></cpp:define>
<comment type="line">//nåã®å ´æã«råã®ç©ãç½®ã</comment>
<function><type><name>mint</name></type> <name>nhr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name>com</name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <name>r</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><type><name>mint</name></type> <name>hom</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name>com</name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <name>r</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><type><name>int</name></type> <name>nhri</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><call><name>icom</name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <name>r</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>T</name></type> <name>minv</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>m</name></decl></parameter>)</parameter_list> <block>{    <decl_stmt><decl><type><name>T</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>v</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <while>while <condition>(<expr><name>a</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{        <decl_stmt><decl><type><name>T</name></type> <name>t</name> <init>= <expr><name>m</name> <operator>/</operator> <name>a</name></expr></init></decl>;</decl_stmt>        <expr_stmt><expr><name>m</name> <operator>-=</operator> <name>t</name> <operator>*</operator> <name>a</name></expr>;</expr_stmt>        <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <expr_stmt><expr><name>u</name> <operator>-=</operator> <name>t</name> <operator>*</operator> <name>v</name></expr>;</expr_stmt>        <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    }</block></while>    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>m</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <return>return <expr><name>u</name></expr>;</return>}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>T</name></type> <name>minv</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{    <if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <name>mint_len</name></expr>)</condition><then><block type="pseudo"><return>return <expr><name><name>inv</name><index>[<expr><name>a</name></expr>]</index></name></expr>;</return></block></then></if>    <decl_stmt><decl><type><name>T</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>v</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <decl_stmt><decl><type><name>T</name></type> <name>m</name> <init>= <expr><name>MOD</name></expr></init></decl>;</decl_stmt>    <while>while <condition>(<expr><name>a</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{        <decl_stmt><decl><type><name>T</name></type> <name>t</name> <init>= <expr><name>m</name> <operator>/</operator> <name>a</name></expr></init></decl>;</decl_stmt>        <expr_stmt><expr><name>m</name> <operator>-=</operator> <name>t</name> <operator>*</operator> <name>a</name></expr>;</expr_stmt>        <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <expr_stmt><expr><name>u</name> <operator>-=</operator> <name>t</name> <operator>*</operator> <name>v</name></expr>;</expr_stmt>        <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    }</block></while>    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>m</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <return>return <expr><name>u</name></expr>;</return>}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>mpow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U</name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>a</name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <decl_stmt><decl><type><name>U</name></type> <name>p</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>    <while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{        <if>if <condition>(<expr><name>p</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><operator>(</operator><name>res</name> <operator>*=</operator> <name>x</name><operator>)</operator> <operator>%=</operator> <name>MOD</name></expr>;</expr_stmt></block></then></if>        <expr_stmt><expr><operator>(</operator><name>x</name> <operator>*=</operator> <name>x</name><operator>)</operator> <operator>%=</operator> <name>MOD</name></expr>;</expr_stmt>        <expr_stmt><expr><name>p</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>    }</block></while>    <return>return <expr><name>res</name></expr>;</return>}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>, <parameter><type><name>typename</name></type> <name>V</name></parameter>&gt;</parameter_list></template> <type><name>mint</name></type> <name>mpow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>V</name></type> <name>m</name> <init>= <expr><name>MOD</name></expr></init></decl></parameter>)</parameter_list> <block>{    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name>a</name></expr></init></decl>, <decl><type ref="prev"/><name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <decl_stmt><decl><type><name>U</name></type> <name>p</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>    <while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{        <if>if <condition>(<expr><name>p</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><operator>(</operator><name>res</name> <operator>*=</operator> <name>x</name><operator>)</operator> <operator>%=</operator> <name>m</name></expr>;</expr_stmt></block></then></if>        <expr_stmt><expr><operator>(</operator><name>x</name> <operator>*=</operator> <name>x</name><operator>)</operator> <operator>%=</operator> <name>m</name></expr>;</expr_stmt>        <expr_stmt><expr><name>p</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>    }</block></while>    <return>return <expr><name>res</name></expr>;</return>}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>&gt;</parameter_list></template> <type><name>mint</name></type> <name>mpow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name>a</name></expr></init></decl>, <decl><type ref="prev"/><name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <decl_stmt><decl><type><name>U</name></type> <name>p</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>    <while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{        <if>if <condition>(<expr><name>p</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><operator>(</operator><name>res</name> <operator>*=</operator> <name>x</name><operator>)</operator> <operator>%=</operator> <name>MOD</name></expr>;</expr_stmt></block></then></if>        <expr_stmt><expr><operator>(</operator><name>x</name> <operator>*=</operator> <name>x</name><operator>)</operator> <operator>%=</operator> <name>MOD</name></expr>;</expr_stmt>        <expr_stmt><expr><name>p</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>    }</block></while>    <return>return <expr><name>res</name></expr>;</return>}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>U</name></parameter>, <parameter><type><name>typename</name></type> <name>V</name></parameter>&gt;</parameter_list></template> <type><name>int</name></type> <name>mpowi</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U</name> <modifier>&amp;</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>V</name> <modifier>&amp;</modifier></type><name>m</name> <init>= <expr><name>MOD</name></expr></init></decl></parameter>)</parameter_list> <block>{    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name>a</name></expr></init></decl>, <decl><type ref="prev"/><name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <decl_stmt><decl><type><name>U</name></type> <name>p</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>    <while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{        <if>if <condition>(<expr><name>p</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><operator>(</operator><name>res</name> <operator>*=</operator> <name>x</name><operator>)</operator> <operator>%=</operator> <name>m</name></expr>;</expr_stmt></block></then></if>        <expr_stmt><expr><operator>(</operator><name>x</name> <operator>*=</operator> <name>x</name><operator>)</operator> <operator>%=</operator> <name>m</name></expr>;</expr_stmt>        <expr_stmt><expr><name>p</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>    }</block></while>    <return>return <expr><name>res</name></expr>;</return>}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name>string</name></type> <name>to_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>number</name></decl></parameter>)</parameter_list> <block>{    <return>return <expr><call><name>to_string</name><argument_list>(<argument><expr><call><name>number</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>}</block></function>
<function><type><name>string</name></type> <name>yuri</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>mint</name> <modifier>&amp;</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{    <decl_stmt><decl><type><name>stringstream</name></type> <name>st</name></decl>;</decl_stmt>    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument><literal type="number">300</literal></argument>)</argument_list></macro> <block>{<macro><name>rep</name><argument_list>(<argument>j</argument>, <argument><literal type="number">300</literal></argument>)</argument_list></macro> <block>{<if>if <condition>(<expr><operator>(</operator><name>mint</name><operator>)</operator> <name>i</name> <operator>/</operator> <name>j</name> <operator>==</operator> <name>a</name></expr>)</condition><then> <block>{<expr_stmt><expr><name>st</name> <operator>&lt;&lt;</operator> <name>i</name> <operator>&lt;&lt;</operator> <literal type="string">" / "</literal> <operator>&lt;&lt;</operator> <name>j</name></expr>;</expr_stmt><return>return <expr><call><name><name>st</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></then></if>}</block>}</block>    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument><literal type="number">1000</literal></argument>)</argument_list></macro> <block>{<macro><name>rep</name><argument_list>(<argument>j</argument>, <argument><literal type="number">1000</literal></argument>)</argument_list></macro> <block>{<if>if <condition>(<expr><operator>(</operator><name>mint</name><operator>)</operator> <name>i</name> <operator>/</operator> <name>j</name> <operator>==</operator> <name>a</name></expr>)</condition><then> <block>{<expr_stmt><expr><name>st</name> <operator>&lt;&lt;</operator> <name>i</name> <operator>&lt;&lt;</operator> <literal type="string">" / "</literal> <operator>&lt;&lt;</operator> <name>j</name></expr>;</expr_stmt><return>return <expr><call><name><name>st</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></then></if>}</block>}</block>    <return>return <expr><call><name><name>st</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></function>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name><name>std</name><operator>::</operator><name>ostream</name></name> <modifier>&amp;</modifier></type><name>operator<name>&lt;&lt;</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>ostream</name></name> <modifier>&amp;</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>number</name></decl></parameter>)</parameter_list> <block>{<expr_stmt><expr><name>stream</name> <operator>&lt;&lt;</operator> <call><name>number</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_DEBUG</name></cpp:ifdef>
<comment type="line">//    stream &lt;&lt; " -&gt; " &lt;&lt; yuri(number);</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>stream</name></expr>;</return>
}</block></function>
<comment type="line">//@formatter:off</comment>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <type><name><name>std</name><operator>::</operator><name>istream</name></name> <modifier>&amp;</modifier></type><name>operator<name>&gt;&gt;</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>istream</name></name> <modifier>&amp;</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>number</name></decl></parameter>)</parameter_list> <block>{    <decl_stmt><decl><type><name><typename>typename</typename> <name><name>common_type</name><argument_list type="generic">&lt;<argument><expr><name><typename>typename</typename> <name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Type</name></name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></name></type> <name>x</name></decl>;</decl_stmt>    <expr_stmt><expr><name>stream</name> <operator>&gt;&gt;</operator> <name>x</name></expr>;</expr_stmt>    <expr_stmt><expr><name><name>number</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name><name><name>Modular</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>normalize</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <return>return <expr><name>stream</name></expr>;</return>}</block></function>
<using>using <name>PM</name> <init>= <type><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>mint</name></expr></argument>, <argument><expr><name>mint</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<using>using <name>vm</name> <init>= <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>mint</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<using>using <name>mapm</name> <init>= <type><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>mint</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<using>using <name>umapm</name> <init>= <type><name><name>umap</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>mint</name></expr></argument>&gt;</argument_list></name></type></init>;</using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vvm</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(mint,__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vnm</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>auto name = make_v&lt;mint&gt;(__VA_ARGS__)</cpp:value></cpp:define>

<struct>struct <name>setmod</name><block>{<public type="default">
    <constructor><name>setmod</name><parameter_list>()</parameter_list> <block>{
<comment type="line">//    p2.resize(mint_len);p2[0] = 1; for (int i = 1; i &lt; mint_len; ++i) p2[i] = p2[i - 1] * 2 % MOD;</comment>
        <expr_stmt><expr><call><name><name>fac</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>mint_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <expr_stmt><expr><call><name><name>finv</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>mint_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <expr_stmt><expr><call><name><name>inv</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>mint_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <expr_stmt><expr><name><name>inv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>fac</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>finv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mint_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block type="pseudo"><expr_stmt><expr><name><name>inv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>inv</name><index>[<expr><name>MOD</name> <operator>%</operator> <name>i</name></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>MOD</name> <operator>-</operator> <name>MOD</name> <operator>/</operator> <name>i</name><operator>)</operator> <operator>%</operator> <name>MOD</name></expr>;</expr_stmt></block></for>    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mint_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block type="pseudo"><expr_stmt><expr><name><name>fac</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>fac</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>i</name> <operator>%</operator> <name>MOD</name></expr><operator>,</operator> <expr><name><name>finv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>finv</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>inv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>%</operator> <name>MOD</name></expr>;</expr_stmt></block></for>
    }</block></constructor>
</public>}</block><decl><name>setmodv</name></decl>;</struct>
<comment type="line">//@formatter:on</comment>
<comment type="line">//nhr nåã®å ´æã«råã®ç©ãåãã</comment>

<function><type><name>signed</name></type> <name>main</name><parameter_list>()</parameter_list> <block>{
    <expr_stmt><expr><call><name>din</name><argument_list>(<argument><expr><name>H</name></expr></argument>,<argument><expr><name>W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>vm</name></type> <name>add</name><argument_list>(<argument><expr><name>k5</name> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>add</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>add</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <macro><name>rep</name><argument_list>(<argument>i</argument>, <argument><literal type="number">2</literal></argument>, <argument>k5 * <literal type="number">3</literal></argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name><name>add</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>add</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>add</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    }</block>
    <decl_stmt><decl><type><name>mint</name></type> <name>res</name> <init>= <expr><name><name>add</name><index>[<expr><name>W</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>res</name> <operator>+=</operator> <name><name>add</name><index>[<expr><name>H</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <name>res</name> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
}</block></function></unit>
