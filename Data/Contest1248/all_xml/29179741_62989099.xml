<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="0.9.5" language="C++" filename="Data/Contest1248/all/29179741_62989099.cpp"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_USE_MATH_DEFINES</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;iostream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;vector&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;set&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;queue&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;map&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;cstring&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;cmath&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;climits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;iomanip&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;stack&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;unordered_map&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;bitset&gt;</cpp:file></cpp:include>
<using>using <namespace>namespace <name>std</name>;</namespace></using>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOD</name></cpp:macro> <cpp:value>1000000007</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rep</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>m</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for(int (i)=(int)(m);i&lt;(int)(n);i++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REP</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rep(i,0,n)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOR</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ll</name></cpp:macro> <cpp:value>long long</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ull</name></cpp:macro> <cpp:value>unsigned long long</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>all</name><parameter_list>(<parameter><type><name>hoge</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(hoge).begin(),(hoge).end()</cpp:value></cpp:define>
<typedef>typedef <type><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name></type> <name>P</name>;</typedef>
<decl_stmt><decl><type><specifier>const</specifier> <name>long</name> <name>long</name></type> <name>INF</name> <init>= <expr><literal type="number">1LL</literal> <operator>&lt;&lt;</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name></type> <name>Array</name>;</typedef>
<typedef>typedef <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Array</name></expr></argument>&gt;</argument_list></name></type> <name>Matrix</name>;</typedef>
<function type="operator"><type><name>string</name></type> <name>operator<name>*</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>string</name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list> <block>{
	<if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="string">""</literal></expr>;</return></block></then></if>
	<decl_stmt><decl><type><name>string</name></type> <name>p</name> <init>= <expr><operator>(</operator><name>s</name> <operator>+</operator> <name>s</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>k</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>k</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>p</name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt></block></then></if>
	<return>return <expr><name>p</name></expr>;</return>
}</block></function>



<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>bool</name></type> <name>chmin</name><parameter_list>(<parameter><decl><type><name>T</name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{
	<if>if <condition>(<expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
		<return>return <expr><literal type="boolean">true</literal></expr>;</return>
	}</block></then></if>
	<return>return <expr><literal type="boolean">false</literal></expr>;</return>
}</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template> <specifier>inline</specifier> <type><name>bool</name></type> <name>chmax</name><parameter_list>(<parameter><decl><type><name>T</name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{
	<if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
		<return>return <expr><literal type="boolean">true</literal></expr>;</return>
	}</block></then></if>
	<return>return <expr><literal type="boolean">false</literal></expr>;</return>
}</block></function>




<struct>struct <name>Edge</name> <block>{<public type="default"><comment type="line">//ã°ã©ã</comment>
	<decl_stmt><decl><type><name>ll</name></type> <name>to</name></decl>, <decl><type ref="prev"/><name>cap</name></decl>, <decl><type ref="prev"/><name>rev</name></decl>;</decl_stmt>
	<constructor><name>Edge</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>_to</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>_cap</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>_rev</name></decl></parameter>)</parameter_list> <block>{
		<expr_stmt><expr><name>to</name> <operator>=</operator> <name>_to</name></expr>;</expr_stmt> <expr_stmt><expr><name>cap</name> <operator>=</operator> <name>_cap</name></expr>;</expr_stmt> <expr_stmt><expr><name>rev</name> <operator>=</operator> <name>_rev</name></expr>;</expr_stmt>
	}</block></constructor>
</public>}</block>;</struct>
<typedef>typedef <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Edge</name></expr></argument>&gt;</argument_list></name></type> <name>Edges</name>;</typedef>
<typedef>typedef <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Edges</name></expr></argument>&gt;</argument_list></name></type> <name>Graph</name>;</typedef>
<function><type><name>void</name></type> <name>add_edge</name><parameter_list>(<parameter><decl><type><name>Graph</name><modifier>&amp;</modifier></type> <name>G</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>cap</name></decl></parameter>,<parameter><decl><type><name>bool</name></type> <name>revFlag</name></decl></parameter>,<parameter><decl><type><name>ll</name></type> <name>revCap</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//æå¤§ãã­ã¼æ±ãã Ford-fulkerson</comment>
	<expr_stmt><expr><name><name>G</name><index>[<expr><name>from</name></expr>]</index></name><operator>.</operator><call><name>push_back</name><argument_list>(<argument><expr><call><name>Edge</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>cap</name></expr></argument>, <argument><expr><operator>(</operator><name>ll</name><operator>)</operator><name><name>G</name><index>[<expr><name>to</name></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if<condition>(<expr><name>revFlag</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name><name>G</name><index>[<expr><name>to</name></expr>]</index></name><operator>.</operator><call><name>push_back</name><argument_list>(<argument><expr><call><name>Edge</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>revCap</name></expr></argument>, <argument><expr><operator>(</operator><name>ll</name><operator>)</operator><name><name>G</name><index>[<expr><name>from</name></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if><comment type="line">//æå°ã«ããã®å ´åéè¾ºã¯0ã«ãã</comment>
}</block></function>
<function><type><name>ll</name></type> <name>max_flow_dfs</name><parameter_list>(<parameter><decl><type><name>Graph</name> <modifier>&amp;</modifier></type> <name>G</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type> <name>used</name></decl></parameter>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>t</name></expr>)</condition><then>
		<block type="pseudo"><return>return <expr><name>f</name></expr>;</return></block></then></if>
	<expr_stmt><expr><name><name>used</name><index>[<expr><name>v</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>G</name><index>[<expr><name>v</name></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
		<decl_stmt><decl><type><name>Edge</name><modifier>&amp;</modifier></type> <name>e</name> <init>= <expr><name><name>G</name><index>[<expr><name>v</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><operator>!</operator><name><name>used</name><index>[<expr><name><name>e</name><operator>.</operator><name>to</name></name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>e</name><operator>.</operator><name>cap</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>ll</name></type> <name>d</name> <init>= <expr><call><name>max_flow_dfs</name><argument_list>(<argument><expr><name>G</name></expr></argument>, <argument><expr><name><name>e</name><operator>.</operator><name>to</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>min</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>e</name><operator>.</operator><name>cap</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>used</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>d</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>e</name><operator>.</operator><name>cap</name></name> <operator>-=</operator> <name>d</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>G</name><index>[<expr><name><name>e</name><operator>.</operator><name>to</name></name></expr>]</index><index>[<expr><name><name>e</name><operator>.</operator><name>rev</name></name></expr>]</index></name><operator>.</operator><name>cap</name> <operator>+=</operator> <name>d</name></expr>;</expr_stmt>
				<return>return <expr><name>d</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></for>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
}</block></function>
<comment type="line">//äºåã°ã©ãã®æå¤§ãããã³ã°ãæ±ããããåºæ¥ããã¾ãäºé¨ã°ã©ãã®æå¤§ç¬ç«éåã¯é ç¹æ°-æå¤§ãããã³ã°ã®ãµã¤ãº</comment>
<function><type><name>ll</name></type> <name>max_flow</name><parameter_list>(<parameter><decl><type><name>Graph</name> <modifier>&amp;</modifier></type> <name>G</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>t</name></decl></parameter>)</parameter_list><comment type="line">//O(V(V+E))</comment>
<block>{
	<decl_stmt><decl><type><name>ll</name></type> <name>flow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{
		<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></type> <name>used</name><argument_list>(<argument><expr><call><name><name>G</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
		<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>used.size()</argument>)</argument_list></macro><expr_stmt><expr><name><name>used</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>ll</name></type> <name>f</name> <init>= <expr><call><name>max_flow_dfs</name><argument_list>(<argument><expr><name>G</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>INF</name></expr></argument>, <argument><expr><name>used</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
			<return>return <expr><name>flow</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>flow</name> <operator>+=</operator> <name>f</name></expr>;</expr_stmt>
	}</block></for>
}</block></function>
<function><type><name>void</name></type> <name>BellmanFord</name><parameter_list>(<parameter><decl><type><name>Graph</name><modifier>&amp;</modifier></type> <name>G</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>Array</name><modifier>&amp;</modifier></type> <name>d</name></decl></parameter>,<parameter><decl><type><name>Array</name> <modifier>&amp;</modifier></type><name>negative</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//O(|E||V|)</comment>
	<expr_stmt><expr><call><name><name>d</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>G</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>negative</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>G</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>d.size()</argument>)</argument_list></macro><expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>INF</name></expr>;</expr_stmt>
	<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>d.size()</argument>)</argument_list></macro><expr_stmt><expr><name><name>negative</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>REP</name><argument_list>(<argument>k</argument>, <argument>G.size()-<literal type="number">1</literal></argument>)</argument_list></macro> <block>{
		<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>G.size()</argument>)</argument_list></macro> <block>{
			<macro><name>REP</name><argument_list>(<argument>j</argument>, <argument>G[i].size()</argument>)</argument_list></macro> <block>{
				<if>if <condition>(<expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>INF</name> <operator>&amp;&amp;</operator> <name><name>d</name><index>[<expr><name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>to</name></expr>]</index></name> <operator>&gt;</operator> <name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cap</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>d</name><index>[<expr><name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>to</name></expr>]</index></name> <operator>=</operator> <name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cap</name></expr>;</expr_stmt>
				}</block></then></if>
			}</block>
		}</block>
	}</block>
	<macro><name>REP</name><argument_list>(<argument>k</argument>, <argument>G.size() - <literal type="number">1</literal></argument>)</argument_list></macro> <block>{
		<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>G.size()</argument>)</argument_list></macro> <block>{
			<macro><name>REP</name><argument_list>(<argument>j</argument>, <argument>G[i].size()</argument>)</argument_list></macro> <block>{
				<if>if <condition>(<expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>INF</name> <operator>&amp;&amp;</operator> <name><name>d</name><index>[<expr><name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>to</name></expr>]</index></name> <operator>&gt;</operator> <name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cap</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>d</name><index>[<expr><name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>to</name></expr>]</index></name> <operator>=</operator> <name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cap</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>negative</name><index>[<expr><name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>to</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
				}</block></then></if>
				<if>if<condition>(<expr><name><name>negative</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="boolean">true</literal></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name><name>negative</name><index>[<expr><name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>to</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block></then></if>
			}</block>
		}</block>
	}</block>
}</block></function>
<function><type><name>void</name></type> <name>Dijkstra</name><parameter_list>(<parameter><decl><type><name>Graph</name><modifier>&amp;</modifier></type> <name>G</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>Array</name><modifier>&amp;</modifier></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//O(|E|log|V|)</comment>
	<expr_stmt><expr><call><name><name>d</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>G</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>d.size()</argument>)</argument_list></macro><expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>INF</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>priority_queue</name><argument_list type="generic">&lt;<argument><expr><name>P</name></expr></argument>, <argument><expr><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>P</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name><name>greater</name><argument_list type="generic">&lt;<argument><expr><name>P</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>q</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name><name>q</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name>make_pair</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><call><name><name>q</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>P</name></type> <name>a</name> <init>= <expr><call><name><name>q</name><operator>.</operator><name>top</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name><name>q</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>d</name><index>[<expr><name><name>a</name><operator>.</operator><name>second</name></name></expr>]</index></name> <operator>&lt;</operator> <name><name>a</name><operator>.</operator><name>first</name></name></expr>)</condition><then><block type="pseudo"><continue>continue;</continue></block></then></if>
		<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>G[a.second].size()</argument>)</argument_list></macro> <block>{
			<decl_stmt><decl><type><name>Edge</name></type> <name>e</name> <init>= <expr><name><name>G</name><index>[<expr><name><name>a</name><operator>.</operator><name>second</name></name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name><name>d</name><index>[<expr><name><name>e</name><operator>.</operator><name>to</name></name></expr>]</index></name> <operator>&gt;</operator> <name><name>d</name><index>[<expr><name><name>a</name><operator>.</operator><name>second</name></name></expr>]</index></name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>cap</name></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>d</name><index>[<expr><name><name>e</name><operator>.</operator><name>to</name></name></expr>]</index></name> <operator>=</operator> <name><name>d</name><index>[<expr><name><name>a</name><operator>.</operator><name>second</name></name></expr>]</index></name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>cap</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name><name>q</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><call><name>make_pair</name><argument_list>(<argument><expr><name><name>d</name><index>[<expr><name><name>e</name><operator>.</operator><name>to</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>e</name><operator>.</operator><name>to</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		}</block>
	}</block></while>
}</block></function>
<function><type><name>void</name></type> <name>WarshallFloyd</name><parameter_list>(<parameter><decl><type><name>Graph</name><modifier>&amp;</modifier></type> <name>G</name></decl></parameter>, <parameter><decl><type><name>Matrix</name><modifier>&amp;</modifier></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//O(V^3)</comment>
	<expr_stmt><expr><call><name><name>d</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>G</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>d.size()</argument>)</argument_list></macro><expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>resize</name><argument_list>(<argument><expr><call><name><name>G</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>d.size()</argument>)</argument_list></macro> <block>{
		<macro><name>REP</name><argument_list>(<argument>j</argument>, <argument>d[i].size()</argument>)</argument_list></macro> <block>{
			<expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>INF</name></expr>;</expr_stmt>
		}</block>
	}</block>
	<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>G.size()</argument>)</argument_list></macro> <block>{
		<macro><name>REP</name><argument_list>(<argument>j</argument>, <argument>G[i].size()</argument>)</argument_list></macro> <block>{
			<expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>to</name></expr>]</index></name> <operator>=</operator> <name><name>G</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cap</name></expr>;</expr_stmt>
		}</block>
	}</block>
	<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>G.size()</argument>)</argument_list></macro> <block>{
		<macro><name>REP</name><argument_list>(<argument>j</argument>, <argument>G.size()</argument>)</argument_list></macro> <block>{
			<macro><name>REP</name><argument_list>(<argument>k</argument>, <argument>G.size()</argument>)</argument_list></macro> <block>{
				<expr_stmt><expr><call><name>chmin</name><argument_list>(<argument><expr><name><name>d</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>d</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>d</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block>
		}</block>
	}</block>
}</block></function>
<function><type><name>bool</name></type> <name>tsort</name><parameter_list>(<parameter><decl><type><name>Graph</name><modifier>&amp;</modifier></type> <name>graph</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>order</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//ããã­ã¸ã«ã«ã½ã¼ãO(E+V)</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name><name>graph</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Array</name></type> <name>in</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>auto</name><operator>&amp;</operator> <name>es</name> <operator>:</operator> <name>graph</name></expr></init>)</control>
		<block type="pseudo"><for>for <control>(<init><expr><name>auto</name><operator>&amp;</operator> <name>e</name> <operator>:</operator> <name>es</name></expr></init>)</control><block type="pseudo"><expr_stmt><expr><name><name>in</name><index>[<expr><name><name>e</name><operator>.</operator><name>to</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block></for></block></for>
	<decl_stmt><decl><type><name><name>priority_queue</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>, <argument><expr><name>Array</name></expr></argument>, <argument><expr><name><name>greater</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>que</name></decl>;</decl_stmt>
	<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro>
		<if>if <condition>(<expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><call><name><name>que</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
	<while>while <condition>(<expr><call><name><name>que</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><call><name><name>que</name><operator>.</operator><name>top</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name><name>que</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>order</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>auto</name><operator>&amp;</operator> <name>e</name> <operator>:</operator> <name><name>graph</name><index>[<expr><name>v</name></expr>]</index></name></expr></init>)</control>
			<block type="pseudo"><if>if <condition>(<expr><operator>--</operator><name><name>in</name><index>[<expr><name><name>e</name><operator>.</operator><name>to</name></name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><call><name><name>que</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if></block></for>
	}</block></while>
	<if>if <condition>(<expr><call><name><name>order</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>n</name></expr>)</condition><then><block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then>
	<else>else <block type="pseudo"><return>return <expr><literal type="boolean">true</literal></expr>;</return></block></else></if>
}</block></function>
<class>class <name>lca</name> <block>{<private type="default">
</private><public>public:
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>log2_n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></name></expr></argument>&gt;</argument_list></name></name></type> <name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></name></type> <name>depth</name></decl>;</decl_stmt>

	<constructor><name>lca</name><parameter_list>()</parameter_list> <block>{}</block></constructor>

	<constructor><name>lca</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name><modifier>&amp;</modifier></type> <name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>root</name></decl></parameter>)</parameter_list>
		<member_init_list>: <call><name>n</name><argument_list>(<argument><expr><call><name><name>g</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>, <call><name>log2_n</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>, <call><name>parent</name><argument_list>(<argument><expr><name>log2_n</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>, <call><name>depth</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> </member_init_list><block>{
		<expr_stmt><expr><call><name>dfs</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>log2_n</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{
			<for>for <control>(<init><decl><type><name>int</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>v</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name><name>g</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>v</name><operator>++</operator></expr></incr>)</control> <block>{
				<if>if <condition>(<expr><name><name>parent</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>v</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then>
					<block type="pseudo"><expr_stmt><expr><name><name>parent</name><index>[<expr><name>k</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>v</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block></then>
				<else>else
					<block type="pseudo"><expr_stmt><expr><name><name>parent</name><index>[<expr><name>k</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>v</name></expr>]</index></name> <operator>=</operator> <name><name>parent</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name><name>parent</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>v</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block></else></if>
			}</block></for>
		}</block></for>
	}</block></constructor>

	<function><type><name>void</name></type> <name>dfs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Graph</name><modifier>&amp;</modifier></type> <name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{
		<expr_stmt><expr><name><name>parent</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>v</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>depth</name><index>[<expr><name>v</name></expr>]</index></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>auto</name><operator>&amp;</operator> <name>e</name> <operator>:</operator> <name><name>g</name><index>[<expr><name>v</name></expr>]</index></name></expr></init>)</control> <block>{
			<if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>to</name></name> <operator>!=</operator> <name>p</name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>dfs</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>e</name><operator>.</operator><name>to</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
		}</block></for>
	}</block></function>

	<function><type><name>int</name></type> <name>get</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>u</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{
		<if>if <condition>(<expr><name><name>depth</name><index>[<expr><name>u</name></expr>]</index></name> <operator>&gt;</operator> <name><name>depth</name><index>[<expr><name>v</name></expr>]</index></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>swap</name></name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>log2_n</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{
			<if>if <condition>(<expr><operator>(</operator><name><name>depth</name><index>[<expr><name>v</name></expr>]</index></name> <operator>-</operator> <name><name>depth</name><index>[<expr><name>u</name></expr>]</index></name><operator>)</operator> <operator>&gt;&gt;</operator> <name>k</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>parent</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>v</name></expr>]</index></name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>
		<if>if <condition>(<expr><name>u</name> <operator>==</operator> <name>v</name></expr>)</condition><then> <block type="pseudo"><return>return <expr><name>u</name></expr>;</return></block></then></if>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><name>log2_n</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control> <block>{
			<if>if <condition>(<expr><name><name>parent</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>u</name></expr>]</index></name> <operator>!=</operator> <name><name>parent</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>v</name></expr>]</index></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>u</name> <operator>=</operator> <name><name>parent</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>u</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>parent</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>v</name></expr>]</index></name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>
		<return>return <expr><name><name>parent</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>u</name></expr>]</index></name></expr>;</return>
	}</block></function>
</public>}</block>;</class>


<class>class <name>UnionFind</name> <block>{<private type="default">
	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ll</name></type> <name>num</name></decl>;</decl_stmt>
</private><public>public:
	<constructor><name>UnionFind</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <member_init_list>: <call><name>data</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call>, <call><name>num</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call> </member_init_list><block>{ }</block></constructor>
	<function><type><name>bool</name></type> <name>unite</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//xã¨yã®éåãçµ±åãã</comment>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>root</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>root</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> <operator>!=</operator> <name>y</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>data</name><index>[<expr><name>y</name></expr>]</index></name> <operator>&lt;</operator> <name><name>data</name><index>[<expr><name>x</name></expr>]</index></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
			<expr_stmt><expr><name><name>data</name><index>[<expr><name>x</name></expr>]</index></name> <operator>+=</operator> <name><name>data</name><index>[<expr><name>y</name></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>data</name><index>[<expr><name>y</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>num</name> <operator>-=</operator> <operator>(</operator><name>x</name> <operator>!=</operator> <name>y</name><operator>)</operator></expr>;</expr_stmt>
		<return>return <expr><name>x</name> <operator>!=</operator> <name>y</name></expr>;</return>
	}</block></function>
	<function><type><name>bool</name></type> <name>findSet</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//xã¨yãåãéåãè¿ã</comment>
		<return>return <expr><call><name>root</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>root</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></function>
	<function><type><name>int</name></type> <name>root</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//xã®ã«ã¼ããè¿ã</comment>
		<return>return <expr><ternary><condition><expr><name><name>data</name><index>[<expr><name>x</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>x</name></expr> </then><else>: <expr><name><name>data</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <call><name>root</name><argument_list>(<argument><expr><name><name>data</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
	}</block></function>
	<function><type><name>int</name></type> <name>size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//xã®éåã®ãµã¤ãºãè¿ã</comment>
		<return>return <expr><operator>-</operator><name><name>data</name><index>[<expr><call><name>root</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</return>
	}</block></function>
	<function><type><name>int</name></type> <name>numSet</name><parameter_list>()</parameter_list> <block>{<comment type="line">//éåã®æ°ãè¿ã</comment>
		<return>return <expr><name>num</name></expr>;</return>
	}</block></function>
</public>}</block>;</class>
<class>class <name>SumSegTree</name> <block>{<private type="default">
</private><private>private:
	
	<function><type><name>ll</name></type> <name>_sum</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{
		<if>if <condition>(<expr><name>r</name> <operator>&lt;=</operator> <name>a</name> <operator>||</operator> <name>b</name> <operator>&lt;=</operator> <name>l</name></expr>)</condition><then><block type="pseudo"><return>return <expr><literal type="number">0</literal></expr>;</return></block></then></if>    <comment type="line">// äº¤å·®ããªã</comment>
		<if>if <condition>(<expr><name>a</name> <operator>&lt;=</operator> <name>l</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>&lt;=</operator> <name>b</name></expr>)</condition><then><block type="pseudo"><return>return <expr><name><name>dat</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</return></block></then>   <comment type="line">// a,l,r,bã®é ã§å®å¨ã«å«ã¾ãã</comment>
		<else>else <block>{
			<decl_stmt><decl><type><name>ll</name></type> <name>s1</name> <init>= <expr><call><name>_sum</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>k</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><operator>(</operator><name>l</name> <operator>+</operator> <name>r</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// å·¦ã®å­</comment>
			<decl_stmt><decl><type><name>ll</name></type> <name>s2</name> <init>= <expr><call><name>_sum</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>k</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>l</name> <operator>+</operator> <name>r</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// å³ã®å­</comment>
			<return>return <expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>;</return>
		}</block></else></if>
	}</block></function>
</private><public>public:
	<decl_stmt><decl><type><name>ll</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>height</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name></type> <name>dat</name></decl>;</decl_stmt>

	<comment type="line">// åæåï¼_nã¯æå¤§è¦ç´ æ°ï¼</comment>
	<constructor><name>SumSegTree</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>_n</name></decl></parameter>)</parameter_list> <block>{
		<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>height</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>_n</name></expr>)</condition> <block>{
			<expr_stmt><expr><name>n</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>height</name><operator>++</operator></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><name>dat</name> <operator>=</operator> <call><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></constructor>

	<comment type="line">// å ´æi(0-indexed)ã«xãè¶³ã</comment>
	<function><type><name>void</name></type> <name>add</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{
		<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// içªç®ã®èãã¼ãã¸</comment>
		<expr_stmt><expr><name><name>dat</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>x</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{ <comment type="line">// ä¸ããä¸ãã£ã¦ãã</comment>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dat</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>x</name></expr>;</expr_stmt>
		}</block></while>
	}</block></function>

	<comment type="line">// åºé[a,b)ã®ç·åããã¼ãk=[l,r)ã«çç®ãã¦ããã</comment>
	<function><type><name>ll</name></type> <name>sum</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{
		<return>return <expr><call><name>_sum</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></function>
</public>}</block>;</class>
<class>class <name>RmqTree</name> <block>{<private type="default">
</private><private>private:

	<function><type><name>ll</name></type> <name>_find</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{
		<if>if <condition>(<expr><name>r</name> <operator>&lt;=</operator> <name>a</name> <operator>||</operator> <name>b</name> <operator>&lt;=</operator> <name>l</name></expr>)</condition><then><block type="pseudo"><return>return <expr><name>INF</name></expr>;</return></block></then></if>    <comment type="line">// äº¤å·®ããªã</comment>
		<if>if <condition>(<expr><name>a</name> <operator>&lt;=</operator> <name>l</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>&lt;=</operator> <name>b</name></expr>)</condition><then><block type="pseudo"><return>return <expr><name><name>dat</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</return></block></then>   <comment type="line">// a,l,r,bã®é ã§å®å¨ã«å«ã¾ãã</comment>
		<else>else <block>{
			<decl_stmt><decl><type><name>ll</name></type> <name>s1</name> <init>= <expr><call><name>_find</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>k</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><operator>(</operator><name>l</name> <operator>+</operator> <name>r</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// å·¦ã®å­</comment>
			<decl_stmt><decl><type><name>ll</name></type> <name>s2</name> <init>= <expr><call><name>_find</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>k</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>l</name> <operator>+</operator> <name>r</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// å³ã®å­</comment>
			<return>return <expr><call><name>min</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></else></if>
	}</block></function>
</private><public>public:
	<decl_stmt><decl><type><name>ll</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>height</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name></type> <name>dat</name></decl>;</decl_stmt>

	<comment type="line">// åæåï¼_nã¯æå¤§è¦ç´ æ°ï¼</comment>
	<constructor><name>RmqTree</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>_n</name></decl></parameter>)</parameter_list> <block>{
		<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>height</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>_n</name></expr>)</condition> <block>{
			<expr_stmt><expr><name>n</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>height</name><operator>++</operator></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><name>dat</name> <operator>=</operator> <call><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,<argument><expr><name>INF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></constructor>

	<comment type="line">// å ´æi(0-indexed)ãxã«ãã</comment>
	<function><type><name>void</name></type> <name>update</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{
		<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// içªç®ã®èãã¼ãã¸</comment>
		<expr_stmt><expr><name><name>dat</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{ <comment type="line">// ä¸ããä¸ãã£ã¦ãã</comment>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dat</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>min</name><argument_list>(<argument><expr><name><name>dat</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>dat</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
	}</block></function>

	<comment type="line">// åºé[a,b)ã®æå°å¤ããã¼ãk=[l,r)ã«çç®ãã¦ããã</comment>
	<function><type><name>ll</name></type> <name>find</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{
		<return>return <expr><call><name>_find</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></function>
</public>}</block>;</class>


<comment type="line">//ç´æ°æ±ãã //ç´æ°</comment>
<function><type><name>void</name></type> <name>divisor</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>ret</name></decl></parameter>)</parameter_list> <block>{
	<for>for <control>(<init><decl><type><name>ll</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>*</operator> <name>i</name> <operator>&lt;=</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
		<if>if <condition>(<expr><name>n</name> <operator>%</operator> <name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name><name>ret</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>i</name> <operator>*</operator> <name>i</name> <operator>!=</operator> <name>n</name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name><name>ret</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>n</name> <operator>/</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><call><name><name>ret</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ret</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

}</block></function>

<function><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name></type> <name>lis_fast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//æé·é¨åå¢å å</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ll</name></type> <name>n</name> <init>= <expr><call><name><name>a</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name></type> <name>A</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name></type> <name>id</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
		<expr_stmt><expr><name><name>id</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>distance</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>lower_bound</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>A</name><index>[<expr><name><name>id</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></for>
	<decl_stmt><decl><type><name>ll</name></type> <name>m</name> <init>= <expr><operator>*</operator><call><name>max_element</name><argument_list>(<argument><expr><call><name><name>id</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>id</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ll</name></expr></argument>&gt;</argument_list></name></type> <name>b</name><argument_list>(<argument><expr><name>m</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control>
		<block type="pseudo"><if>if <condition>(<expr><name><name>id</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>m</name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name><name>b</name><index>[<expr><name>m</name><operator>--</operator></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block></then></if></block></for>
	<return>return <expr><name>b</name></expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name>z_algorithm</name><parameter_list>(<parameter><decl><type><name>string</name> <modifier>&amp;</modifier></type><name>str</name></decl></parameter>,<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>z</name></decl></parameter>,<parameter><decl><type><name>ll</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//s&amp;tãæ¸¡ãã¦tã«sãå«ã¾ããããè¿ã</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>L</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name><name>z</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>left</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>L</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
		<if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>left</name> <operator>=</operator> <name>right</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<for>for <control>(<init>;</init> <condition><expr><name>right</name> <operator>&lt;</operator> <name>L</name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>right</name> <operator>-</operator> <name>left</name></expr>]</index></name> <operator>==</operator> <name><name>str</name><index>[<expr><name>right</name></expr>]</index></name></expr>;</condition> <incr><expr><name>right</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><empty_stmt>;</empty_stmt></block></for>
			<expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>right</name> <operator>-</operator> <name>left</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>right</name><operator>--</operator></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><name>i</name> <operator>-</operator> <name>left</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name><name>z</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&lt;</operator> <name>right</name> <operator>-</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name>left</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<for>for <control>(<init>;</init> <condition><expr><name>right</name> <operator>&lt;</operator> <name>L</name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>right</name> <operator>-</operator> <name>left</name></expr>]</index></name> <operator>==</operator> <name><name>str</name><index>[<expr><name>right</name></expr>]</index></name></expr>;</condition> <incr><expr><name>right</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><empty_stmt>;</empty_stmt></block></for>
				<expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>right</name> <operator>-</operator> <name>left</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>right</name><operator>--</operator></expr>;</expr_stmt>
			}</block></else></if>
		}</block></else></if>
		<if>if <condition>(<expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>s</name></expr>)</condition><then><block type="pseudo"><return>return <expr><literal type="boolean">true</literal></expr>;</return></block></then></if>
	}</block></for>
	<return>return <expr><literal type="boolean">false</literal></expr>;</return>
}</block></function>
<function><type><name>bool</name></type> <name>z_algorithm</name><parameter_list>(<parameter><decl><type><name>string</name><modifier>&amp;</modifier></type> <name>str</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>z</name></decl></parameter>)</parameter_list> <block>{<comment type="line">//z[i]==|s|ã®ã¨ãstr[i]ããsãå«ã¾ãã</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>L</name> <init>= <expr><call><name><name>str</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name><name>z</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>left</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>L</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
		<if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>left</name> <operator>=</operator> <name>right</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<for>for <control>(<init>;</init> <condition><expr><name>right</name> <operator>&lt;</operator> <name>L</name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>right</name> <operator>-</operator> <name>left</name></expr>]</index></name> <operator>==</operator> <name><name>str</name><index>[<expr><name>right</name></expr>]</index></name></expr>;</condition> <incr><expr><name>right</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><empty_stmt>;</empty_stmt></block></for>
			<expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>right</name> <operator>-</operator> <name>left</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>right</name><operator>--</operator></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><name>i</name> <operator>-</operator> <name>left</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name><name>z</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&lt;</operator> <name>right</name> <operator>-</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name>left</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<for>for <control>(<init>;</init> <condition><expr><name>right</name> <operator>&lt;</operator> <name>L</name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>right</name> <operator>-</operator> <name>left</name></expr>]</index></name> <operator>==</operator> <name><name>str</name><index>[<expr><name>right</name></expr>]</index></name></expr>;</condition> <incr><expr><name>right</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><empty_stmt>;</empty_stmt></block></for>
				<expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>right</name> <operator>-</operator> <name>left</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>right</name><operator>--</operator></expr>;</expr_stmt>
			}</block></else></if>
		}</block></else></if>
	}</block></for>
	<return>return <expr><literal type="boolean">true</literal></expr>;</return>
}</block></function>
<comment type="line">// ã­ã¼ãªã³ã°ããã·ã¥</comment>
<comment type="line">// äºåæ¢ç´¢ã§ LCP ãæ±ããæ©è½ã¤ã</comment>
<struct>struct <name>RollingHash</name> <block>{<public type="default">
	<decl_stmt><decl><specifier>static</specifier> <type><specifier>const</specifier> <name>int</name></type> <name>base1</name> <init>= <expr><literal type="number">1007</literal></expr></init></decl>, <decl><type ref="prev"/><name>base2</name> <init>= <expr><literal type="number">2009</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><specifier>static</specifier> <type><specifier>const</specifier> <name>int</name></type> <name>mod1</name> <init>= <expr><literal type="number">1000000007</literal></expr></init></decl>, <decl><type ref="prev"/><name>mod2</name> <init>= <expr><literal type="number">1000000009</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>hash1</name></decl>, <decl><type ref="prev"/><name>hash2</name></decl>, <decl><type ref="prev"/><name>power1</name></decl>, <decl><type ref="prev"/><name>power2</name></decl>;</decl_stmt>

	<comment type="line">// construct</comment>
	<constructor><name>RollingHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>string</name><modifier>&amp;</modifier></type> <name>S</name></decl></parameter>)</parameter_list> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name><name>S</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name><name>hash1</name><operator>.</operator><name>assign</name></name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>hash2</name><operator>.</operator><name>assign</name></name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>power1</name><operator>.</operator><name>assign</name></name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>power2</name><operator>.</operator><name>assign</name></name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
			<expr_stmt><expr><name><name>hash1</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>hash1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>base1</name> <operator>+</operator> <name><name>S</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>%</operator> <name>mod1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hash2</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>hash2</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>base2</name> <operator>+</operator> <name><name>S</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>%</operator> <name>mod2</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>power1</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>power1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>base1</name><operator>)</operator> <operator>%</operator> <name>mod1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>power2</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>power2</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>base2</name><operator>)</operator> <operator>%</operator> <name>mod2</name></expr>;</expr_stmt>
		}</block></for>
	}</block></constructor>

	<comment type="line">// get hash of S[left:right]</comment>
	<function><specifier>inline</specifier> <type><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>, <argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>get</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{
		<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>res1</name> <init>= <expr><name><name>hash1</name><index>[<expr><name>r</name></expr>]</index></name> <operator>-</operator> <name><name>hash1</name><index>[<expr><name>l</name></expr>]</index></name> <operator>*</operator> <name><name>power1</name><index>[<expr><name>r</name> <operator>-</operator> <name>l</name></expr>]</index></name> <operator>%</operator> <name>mod1</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>res1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>res1</name> <operator>+=</operator> <name>mod1</name></expr>;</expr_stmt></block></then></if>
		<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>res2</name> <init>= <expr><name><name>hash2</name><index>[<expr><name>r</name></expr>]</index></name> <operator>-</operator> <name><name>hash2</name><index>[<expr><name>l</name></expr>]</index></name> <operator>*</operator> <name><name>power2</name><index>[<expr><name>r</name> <operator>-</operator> <name>l</name></expr>]</index></name> <operator>%</operator> <name>mod2</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>res2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>res2</name> <operator>+=</operator> <name>mod2</name></expr>;</expr_stmt></block></then></if>
		<return>return <expr><block>{ <expr><name>res1</name></expr>, <expr><name>res2</name></expr> }</block></expr>;</return>
	}</block></function>

	<comment type="line">// get lcp of S[a:] and T[b:]</comment>
	<function><specifier>inline</specifier> <type><name>int</name></type> <name>getLCP</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>min</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name><name>hash1</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name><name>hash1</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>low</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>high</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>high</name> <operator>-</operator> <name>low</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>mid</name> <init>= <expr><operator>(</operator><name>low</name> <operator>+</operator> <name>high</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><call><name>get</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>a</name> <operator>+</operator> <name>mid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>get</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b</name> <operator>+</operator> <name>mid</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block></then>
			<else>else <block type="pseudo"><expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block></else></if>
		}</block></while>
		<return>return <expr><name>low</name></expr>;</return>
	}</block></function>
</public>}</block>;</struct>


<function><type><name>ll</name></type> <name>mod_pow</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>mod</name></decl></parameter>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>ll</name></type> <name>res</name> <init>= <expr><literal type="number">1LL</literal></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{
		<if>if <condition>(<expr><name>n</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>*</operator> <name>x</name> <operator>%</operator> <name>mod</name></expr>;</expr_stmt></block></then></if>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name>x</name> <operator>*</operator> <name>x</name> <operator>%</operator> <name>mod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	}</block></while>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<function><type><name>ll</name></type> <name>mod_inv</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>mod</name></decl></parameter>)</parameter_list> <block>{
	<return>return <expr><call><name>mod_pow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>mod</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<comment type="line">//nCrã¨ã</comment>
<class>class <name>Combination</name> <block>{<private type="default">
</private><public>public:
	<decl_stmt><decl><type><name>Array</name></type> <name>fact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Array</name></type> <name>inv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ll</name></type> <name>mod</name></decl>;</decl_stmt>
	<function><type><name>ll</name></type> <name>mod_inv</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{
		<decl_stmt><decl><type><name>ll</name></type> <name>n</name> <init>= <expr><name>mod</name> <operator>-</operator> <literal type="number">2LL</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ll</name></type> <name>res</name> <init>= <expr><literal type="number">1LL</literal></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{
			<if>if <condition>(<expr><name>n</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>*</operator> <name>x</name> <operator>%</operator> <name>mod</name></expr>;</expr_stmt></block></then></if>
			<expr_stmt><expr><name>x</name> <operator>=</operator> <name>x</name> <operator>*</operator> <name>x</name> <operator>%</operator> <name>mod</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		}</block></while>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></function>
	<function><type><name>ll</name></type> <name>nCr</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{
		<return>return <expr><operator>(</operator><operator>(</operator><name><name>fact</name><index>[<expr><name>n</name></expr>]</index></name> <operator>*</operator> <name><name>inv</name><index>[<expr><name>r</name></expr>]</index></name> <operator>%</operator> <name>mod</name><operator>)</operator> <operator>*</operator> <name><name>inv</name><index>[<expr><name>n</name> <operator>-</operator> <name>r</name></expr>]</index></name><operator>)</operator> <operator>%</operator> <name>mod</name></expr>;</return>
	}</block></function>
	<function><type><name>ll</name></type> <name>nPr</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{
		<return>return <expr><operator>(</operator><name><name>fact</name><index>[<expr><name>n</name></expr>]</index></name> <operator>*</operator> <name><name>inv</name><index>[<expr><name>n</name> <operator>-</operator> <name>r</name></expr>]</index></name><operator>)</operator> <operator>%</operator> <name>mod</name></expr>;</return>
	}</block></function>
	<function><type><name>ll</name></type> <name>nHr</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{
		<return>return <expr><call><name>nCr</name><argument_list>(<argument><expr><name>r</name> <operator>+</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></function>
	<constructor><name>Combination</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>_mod</name></decl></parameter>)</parameter_list> <block>{
		<expr_stmt><expr><name>mod</name> <operator>=</operator> <name>_mod</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>fact</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fact</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>n</argument>)</argument_list></macro> <block>{
			<expr_stmt><expr><name><name>fact</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>fact</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1LL</literal><operator>)</operator><operator>)</operator> <operator>%</operator> <name>mod</name></expr>;</expr_stmt>
		}</block>
		<expr_stmt><expr><call><name><name>inv</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>REP</name><argument_list>(<argument>i</argument>, <argument>n + <literal type="number">1</literal></argument>)</argument_list></macro> <block>{
			<expr_stmt><expr><name><name>inv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>mod_inv</name><argument_list>(<argument><expr><name><name>fact</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block>
	}</block></constructor>
</public>}</block>;</class>


<function><type><name>ll</name></type> <name>gcd</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{
	<if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then><block type="pseudo"><return>return <expr><name>m</name></expr>;</return></block></then></if>
	<return>return <expr><call><name>gcd</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>m</name> <operator>%</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function><comment type="line">//gcd</comment>

<function><type><name>ll</name></type> <name>lcm</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{
	<return>return <expr><name>m</name> <operator>/</operator> <call><name>gcd</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>n</name></expr>;</return>
}</block></function>


<function><type><name>Matrix</name></type> <name>mIdentity</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>Matrix</name></type> <name>A</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>Array</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block type="pseudo"><expr_stmt><expr><name><name>A</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block></for>
	<return>return <expr><name>A</name></expr>;</return>
}</block></function>

<function><type><name>Matrix</name></type> <name>mMul</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Matrix</name> <modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Matrix</name> <modifier>&amp;</modifier></type> <name>B</name></decl></parameter>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>Matrix</name></type> <name>C</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>Array</name><argument_list>(<argument><expr><name><name>B</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>C</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block type="pseudo"><for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>C</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
			<block type="pseudo"><for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>A</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control>
				<block type="pseudo"><expr_stmt><expr><operator>(</operator><name><name>C</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name><name>A</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> <operator>%</operator> <name>MOD</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>B</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>%</operator> <name>MOD</name><operator>)</operator><operator>)</operator> <operator>%=</operator> <name>MOD</name></expr>;</expr_stmt></block></for></block></for></block></for>
	<return>return <expr><name>C</name></expr>;</return>
}</block></function>
<comment type="line">// O( n^3 log e )</comment>
<function><type><name>Matrix</name></type> <name>mPow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Matrix</name> <modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{
	<return>return <expr><ternary><condition><expr><name>e</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>mIdentity</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
		<expr><ternary><condition><expr><name>e</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>mPow</name><argument_list>(<argument><expr><call><name>mMul</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>mMul</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>mPow</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>e</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary></expr>;</return>
}</block></function>

<class><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>class <name>RectangleSum</name> <block>{<private type="default">
</private><public>public:
	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>sum</name></decl>;</decl_stmt>
	<function><type><name>T</name></type> <name>GetSum</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>top</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bottom</name></decl></parameter>)</parameter_list> <block>{ <comment type="line">//[left, right], [top, bottom]</comment>
		<decl_stmt><decl><type><name>T</name></type> <name>res</name> <init>= <expr><name><name>sum</name><index>[<expr><name>bottom</name></expr>]</index><index>[<expr><name>right</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>res</name> <operator>-=</operator> <name><name>sum</name><index>[<expr><name>bottom</name></expr>]</index><index>[<expr><name>left</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block></then></if>
		<if>if <condition>(<expr><name>top</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>res</name> <operator>-=</operator> <name><name>sum</name><index>[<expr><name>top</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>right</name></expr>]</index></name></expr>;</expr_stmt></block></then></if>
		<if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>top</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>res</name> <operator>+=</operator> <name><name>sum</name><index>[<expr><name>top</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>left</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block></then></if>
		<return>return <expr><name>res</name></expr>;</return>
	}</block></function>
	<constructor><name>RectangleSum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>)</parameter_list> <block>{
		<expr_stmt><expr><call><name><name>sum</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>h</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block type="pseudo"><expr_stmt><expr><name><name>sum</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>resize</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></for>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>y</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>h</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{
			<for>for <control>(<init><decl><type><name>int</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>w</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{
				<expr_stmt><expr><name><name>sum</name><index>[<expr><name>y</name></expr>]</index><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>y</name></expr>]</index><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>y</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name><name>sum</name><index>[<expr><name>y</name></expr>]</index><index>[<expr><name>x</name></expr>]</index></name> <operator>+=</operator> <name><name>sum</name><index>[<expr><name>y</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt></block></then></if>
				<if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name><name>sum</name><index>[<expr><name>y</name></expr>]</index><index>[<expr><name>x</name></expr>]</index></name> <operator>+=</operator> <name><name>sum</name><index>[<expr><name>y</name></expr>]</index><index>[<expr><name>x</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block></then></if>
				<if>if <condition>(<expr><name>y</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>x</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name><name>sum</name><index>[<expr><name>y</name></expr>]</index><index>[<expr><name>x</name></expr>]</index></name> <operator>-=</operator> <name><name>sum</name><index>[<expr><name>y</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>x</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block></then></if>
			}</block></for>
		}</block></for>
	}</block></constructor>
</public>}</block>;</class>

<comment type="line">//NTT</comment>
<function><type><name>ll</name></type> <name>_garner</name><parameter_list>(<parameter><decl><type><name>Array</name><modifier>&amp;</modifier></type> <name>xs</name></decl></parameter>, <parameter><decl><type><name>Array</name><modifier>&amp;</modifier></type> <name>mods</name></decl></parameter>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>M</name> <init>= <expr><call><name><name>xs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Array</name></type> <name>coeffs</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></decl>, <decl><type ref="prev"/><name>constants</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>M</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
		<decl_stmt><decl><type><name>ll</name></type> <name>mod_i</name> <init>= <expr><name><name>mods</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="line">// coffs[i] * v + constants[i] == mr[i].val (mod mr[i].first) ãè§£ã</comment>
		<decl_stmt><decl><type><name>ll</name></type> <name>v</name> <init>= <expr><operator>(</operator><name><name>xs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>constants</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>mod_i</name><operator>)</operator> <operator>%</operator> <name>mod_i</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name> <operator>*</operator> <call><name>mod_pow</name><argument_list>(<argument><expr><name><name>coeffs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>mod_i</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>mod_i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <name>mod_i</name></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>M</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
			<decl_stmt><decl><type><name>ll</name></type> <name>mod_j</name> <init>= <expr><name><name>mods</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>constants</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>constants</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+</operator> <name><name>coeffs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name>v</name><operator>)</operator> <operator>%</operator> <name>mod_j</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coeffs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>coeffs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name>mod_i</name><operator>)</operator> <operator>%</operator> <name>mod_j</name></expr>;</expr_stmt>
		}</block></for>
	}</block></for>

	<return>return <expr><call><name><name>constants</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<specifier>inline</specifier> <type><name>void</name></type> <name>bit_reverse</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type> <name>a</name></decl></parameter>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name><name>a</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{
		<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&gt;</operator> <operator>(</operator><name>i</name> <operator>^=</operator> <name>k</name><operator>)</operator></expr>;</condition> <incr><expr><name>k</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr></incr>)</control><block type="pseudo"><empty_stmt>;</empty_stmt></block></for>
		<if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
	}</block></for>
}</block></function>

<class><template>template<parameter_list>&lt;<parameter><type><name>long</name> <name>long</name></type> <name>mod</name></parameter>, <parameter><type><name>long</name> <name>long</name></type> <name>primitive_root</name></parameter>&gt;</parameter_list></template>
class <name>NTT</name> <block>{<private type="default">
</private><public>public:
	<function><type><name>long</name> <name>long</name></type> <name>get_mod</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mod</name></expr>;</return> }</block></function>

	<function><type><name>void</name></type> <name>_ntt</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>)</parameter_list> <block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>n</name> <init>= <expr><call><name><name>a</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>n</name> <operator>^</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <operator>-</operator><name>n</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//n = 2^k</comment>

		<decl_stmt><decl><type><specifier>const</specifier> <name>long</name> <name>long</name></type> <name>g</name> <init>= <expr><name>primitive_root</name></expr></init></decl>;</decl_stmt> <comment type="line">// g is primitive root of mod</comment>

		<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>tmp</name> <init>= <expr><operator>(</operator><name>mod</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <call><name>mod_pow</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>mod</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>mod</name></expr></init></decl>;</decl_stmt> <comment type="line">// -1/n</comment>
		<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>h</name> <init>= <expr><call><name>mod_pow</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// ^nâg</comment>
		<if>if <condition>(<expr><name>sign</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>mod_pow</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>mod</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

		<expr_stmt><expr><call><name>bit_reverse</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>m</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>m</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>m</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>m2</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>m</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>_base</name> <init>= <expr><call><name>mod_pow</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>n</name> <operator>/</operator> <name>m2</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>_w</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>m</name></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control> <block>{
				<for>for <control>(<init><decl><type><name>int</name></type> <name>s</name> <init>= <expr><name>x</name></expr></init></decl>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>s</name> <operator>+=</operator> <name>m2</name></expr></incr>)</control> <block>{
					<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>u</name> <init>= <expr><name><name>a</name><index>[<expr><name>s</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>d</name> <init>= <expr><operator>(</operator><name><name>a</name><index>[<expr><name>s</name> <operator>+</operator> <name>m</name></expr>]</index></name> <operator>*</operator> <name>_w</name><operator>)</operator> <operator>%</operator> <name>mod</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>a</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u</name> <operator>+</operator> <name>d</name><operator>)</operator> <operator>%</operator> <name>mod</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>a</name><index>[<expr><name>s</name> <operator>+</operator> <name>m</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u</name> <operator>-</operator> <name>d</name> <operator>+</operator> <name>mod</name><operator>)</operator> <operator>%</operator> <name>mod</name></expr>;</expr_stmt>
				}</block></for>
				<expr_stmt><expr><name>_w</name> <operator>=</operator> <operator>(</operator><name>_w</name> <operator>*</operator> <name>_base</name><operator>)</operator> <operator>%</operator> <name>mod</name></expr>;</expr_stmt>
			}</block></for>
		}</block></for>
	}</block></function>
	<function><type><name>void</name></type> <name>ntt</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type> <name>input</name></decl></parameter>)</parameter_list> <block>{
		<expr_stmt><expr><call><name>_ntt</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></function>
	<function><type><name>void</name></type> <name>intt</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type> <name>input</name></decl></parameter>)</parameter_list> <block>{
		<expr_stmt><expr><call><name>_ntt</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>long</name> <name>long</name></type> <name>n_inv</name> <init>= <expr><call><name>mod_pow</name><argument_list>(<argument><expr><call><name><name>input</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mod</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>auto</name><operator>&amp;</operator> <name>x</name> <operator>:</operator> <name>input</name></expr></init>)</control> <block type="pseudo"><expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>*</operator> <name>n_inv</name><operator>)</operator> <operator>%</operator> <name>mod</name></expr>;</expr_stmt></block></for>
	}</block></function>

	<comment type="line">// ç³ã¿è¾¼ã¿æ¼ç®ãè¡ã</comment>
	<function><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>convolution</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type> <name>b</name></decl></parameter>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result_size</name> <init>= <expr><call><name><name>a</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>b</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>result_size</name></expr>)</condition> <block type="pseudo"><expr_stmt><expr><name>n</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block></while>

<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>_a</name> <init>= <expr><name>a</name></expr></init></decl>, <decl><type ref="prev"/><name>_b</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>_a</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>_b</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ntt</name><argument_list>(<argument><expr><name>_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ntt</name><argument_list>(<argument><expr><name>_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block type="pseudo"><expr_stmt><expr><name><name>_a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>_a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>_b</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>%</operator> <name>mod</name></expr>;</expr_stmt></block></for>
<expr_stmt><expr><call><name>intt</name><argument_list>(<argument><expr><name>_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>_a</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>result_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>_a</name></expr>;</return>
	}</block></function>
</public>}</block>;</class>

<function><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>convolution_ntt</name><parameter_list>(<parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>mod</name> <init>= <expr><literal type="number">1224736769LL</literal></expr></init></decl></parameter>)</parameter_list> <block>{
	<for>for <control>(<init><expr><name>auto</name><operator>&amp;</operator> <name>x</name> <operator>:</operator> <name>a</name></expr></init>)</control> <block type="pseudo"><expr_stmt><expr><name>x</name> <operator>%=</operator> <name>mod</name></expr>;</expr_stmt></block></for>
	<for>for <control>(<init><expr><name>auto</name><operator>&amp;</operator> <name>x</name> <operator>:</operator> <name>b</name></expr></init>)</control> <block type="pseudo"><expr_stmt><expr><name>x</name> <operator>%=</operator> <name>mod</name></expr>;</expr_stmt></block></for>

	<decl_stmt><decl><type><name>ll</name></type> <name>maxval</name> <init>= <expr><call><name>max</name><argument_list>(<argument><expr><call><name><name>a</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>b</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>*</operator> <operator>*</operator><call><name>max_element</name><argument_list>(<argument><expr><call><name><name>a</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>a</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>*</operator> <operator>*</operator><call><name>max_element</name><argument_list>(<argument><expr><call><name><name>b</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>b</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>maxval</name> <operator>&lt;</operator> <literal type="number">1224736769</literal></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name><name>NTT</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1224736769</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>&gt;</argument_list></name></type> <name>ntt3</name></decl>;</decl_stmt>
		<return>return <expr><call><name><name>ntt3</name><operator>.</operator><name>convolution</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<decl_stmt><decl><type><name><name>NTT</name><argument_list type="generic">&lt;<argument><expr><literal type="number">167772161</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>&gt;</argument_list></name></type> <name>ntt1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>NTT</name><argument_list type="generic">&lt;<argument><expr><literal type="number">469762049</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>&gt;</argument_list></name></type> <name>ntt2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>NTT</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1224736769</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>&gt;</argument_list></name></type> <name>ntt3</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>x1</name> <init>= <expr><call><name><name>ntt1</name><operator>.</operator><name>convolution</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>x2</name> <init>= <expr><call><name><name>ntt2</name><operator>.</operator><name>convolution</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>x3</name> <init>= <expr><call><name><name>ntt3</name><operator>.</operator><name>convolution</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>ret</name><argument_list>(<argument><expr><call><name><name>x1</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>mods</name><argument_list>{ <argument><expr><literal type="number">167772161</literal></expr></argument>, <argument><expr><literal type="number">469762049</literal></expr></argument>, <argument><expr><literal type="number">1224736769</literal></expr></argument>, <argument><expr><name>mod</name></expr></argument> }</argument_list></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>x1</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{
		<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>xs</name><argument_list>{ <argument><expr><name><name>x1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>x2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>x3</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> }</argument_list></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>_garner</name><argument_list>(<argument><expr><name>xs</name></expr></argument>, <argument><expr><name>mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>popcount3</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{
	<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x55555555</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal> <operator>&amp;</operator> <literal type="number">0x55555555</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x33333333</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal> <operator>&amp;</operator> <literal type="number">0x33333333</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x0F0F0F0F</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>&amp;</operator> <literal type="number">0x0F0F0F0F</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x00FF00FF</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal> <operator>&amp;</operator> <literal type="number">0x00FF00FF</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x0000FFFF</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal> <operator>&amp;</operator> <literal type="number">0x0000FFFF</literal><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>x</name></expr>;</return>
}</block></function>


<decl_stmt><decl><type><name>ll</name></type> <name><name>dp</name><index>[<expr><literal type="number">100010</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>main</name><parameter_list>()</parameter_list> <block>{
	<expr_stmt><expr><call><name><name>ios</name><operator>::</operator><name>sync_with_stdio</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>cin</name><operator>.</operator><name>tie</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<decl_stmt><decl><type><name>ll</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>cin</name> <operator>&gt;&gt;</operator> <name>n</name> <operator>&gt;&gt;</operator> <name>m</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>dp</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<macro><name>rep</name><argument_list>(<argument>i</argument>,<argument><literal type="number">1</literal></argument>, <argument>max(n, m)</argument>)</argument_list></macro> <block>{
		<expr_stmt><expr><operator>(</operator><name><name>dp</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name><name>dp</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>dp</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>%=</operator> <name>MOD</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name><name>dp</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name><name>dp</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>%=</operator> <name>MOD</name></expr>;</expr_stmt>
	}</block>
	<decl_stmt><decl><type><name>ll</name></type> <name>ans</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>m</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ans</name> <operator>=</operator> <name><name>dp</name><index>[<expr><call><name>max</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>dp</name><index>[<expr><call><name>max</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ans</name> <operator>%=</operator> <name>MOD</name></expr>;</expr_stmt>
	}</block></then>
	<else>else	<block type="pseudo"><expr_stmt><expr><name>ans</name> <operator>=</operator> <operator>(</operator><name><name>dp</name><index>[<expr><name>n</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>dp</name><index>[<expr><name>n</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>dp</name><index>[<expr><name>m</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>dp</name><index>[<expr><name>m</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>%</operator> <name>MOD</name></expr>;</expr_stmt></block></else></if>
	<expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <name>ans</name> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt>



	<return>return <expr><literal type="number">0</literal></expr>;</return>
}</block></function></unit>
