/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author /dev/null
 */

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template<class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define Mp                          make_pair
#define sep                         ' '
#define endl                        '\n'
#define debug(x)                    cerr << #x << " = " << x << endl
#define SZ(x)                       ll(x.size())
#define fast_io                     ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define set_random                  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 2e5 + 10;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

ll n, p , T , t[MAXN], E[MAXN] , seg[MAXN << 2];
queue<ll> q;
set<ll> st;

void update(int id, int l, int r, int ind, ll val) {
    if (l == r) {
        seg[id] = val;
        return;
    }
    int mid = (l + r) >> 1;
    if (ind <= mid)
        update(2 * id, l, mid, ind, val);
    else
        update(2 * id + 1, mid + 1, r, ind, val);
    seg[id] = min(seg[2 * id], seg[2 * id + 1]);
}

ll get(int id, int l, int r, int ql, int qr) {
    if (ql <= l && r <= qr) {
        return seg[id];
    }
    if (r < ql || qr < l)
        return INF;
    int mid = (l + r) >> 1;
    return min(get(2 * id, l, mid, ql, qr), get(2 * id + 1, mid + 1, r, ql, qr));
}

ll BS(ll i, ll j){
    if (i == 0) return -1;
    if(get(1 , 0 , n + 10 , 1 , i) > j) return -1;
    int l = 0 , r = i + 1;
    while(r - l > 1){
        int mid = (l + r) >> 1;
        if(get(1 , 0 , n + 10 , 1 , mid) <= j)  r = mid;
        else    l = mid;
    }
    return r;
}

void insert(ll x){
    update(1 , 0 , n + 10 , x , INF);
    st.insert(x);
    q.push(x);
    t[x] = INF;
}

int main() {
    fast_io;
    fill(seg , seg + MAXN * 4 , INF);

    cin >> n >> p;
    for (ll i = 1; i <= n; i++) {
        cin >> t[i];
        update(1, 0, n + 10, i, t[i]);
    }

    for(ll i = 0 ; i < 4 * n ; i++){
        if(q.empty()){
            if(get(1 , 0 , n + 10 , 1 , n) >= 2e18) break;
            ll x = BS(n , T);
            if(x == -1){
                x = BS(n , get(1 , 0 , n + 10 , 1 , n));
            }
            T = max(T , t[x]);
            insert(x);
            continue;
        }
        ll A = q.front();
        if(E[A] == 0)   E[A] = T + p;
        ll R = (*st.begin()) - 1;
        ll x = BS(R, T);
        if(x == -1 && R == 0){
            T = max(T , E[q.front()]);
            st.erase(q.front());
            q.pop();
            continue;
        }
        if(x == -1){
            ll mn = get(1 , 0 , n + 10 , 1 , R);
            if(mn >= E[q.front()]){
                T = max(T , E[q.front()]);
                st.erase(q.front());
                q.pop();
                continue;
            }
            x = BS(R , get(1 , 0 , n + 10 , 1 , R));
        }
        T = max(T , t[x]);
        insert(x);
    }
    for(ll i = 1 ; i <= n ; i++)    cout << E[i] << sep;

    return 0;
}
