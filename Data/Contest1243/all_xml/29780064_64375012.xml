<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="0.9.5" language="C++" filename="Data/Contest1243/all/29780064_64375012.cpp"><cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;bits/stdc++.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive><cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ll</name></cpp:macro> <cpp:value>long long</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pb</name></cpp:macro> <cpp:value>push_back</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fast_io</name></cpp:macro> <cpp:value>cin.tie(0);cout.tie(0);ios::sync_with_stdio(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>deb1</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>                <cpp:value>cout&lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;endl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>deb2</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro>             <cpp:value>cout&lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;endl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>deb3</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro>          <cpp:value>cout&lt;&lt;#x&lt;&lt;":" &lt;&lt;x&lt;&lt;" | "&lt;&lt;#y&lt;&lt;": "&lt;&lt;y&lt;&lt;" | "&lt;&lt;#z&lt;&lt;": "&lt;&lt;z&lt;&lt;endl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>deb4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>cout&lt;&lt;#a&lt;&lt;": "&lt;&lt;a&lt;&lt;" | "&lt;&lt;#b&lt;&lt;": "&lt;&lt;b&lt;&lt;" | "&lt;&lt;#c&lt;&lt;": "&lt;&lt;c&lt;&lt;" | "&lt;&lt;#d&lt;&lt;": "&lt;&lt;d&lt;&lt;endl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>deb5</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>cout&lt;&lt;#a&lt;&lt;": "&lt;&lt;a&lt;&lt;" | "&lt;&lt;#b&lt;&lt;": "&lt;&lt;b&lt;&lt;" | "&lt;&lt;#c&lt;&lt;": "&lt;&lt;c&lt;&lt;" | "&lt;&lt;#d&lt;&lt;": "&lt;&lt;d&lt;&lt;" | "&lt;&lt;#e&lt;&lt; ": "&lt;&lt;e&lt;&lt;endl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>deb6</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>e</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cout&lt;&lt;#a&lt;&lt;": "&lt;&lt;a&lt;&lt;" | "&lt;&lt;#b&lt;&lt;": "&lt;&lt;b&lt;&lt;" | "&lt;&lt;#c&lt;&lt;": "&lt;&lt;c&lt;&lt;" | "&lt;&lt;#d&lt;&lt;": "&lt;&lt;d&lt;&lt;" | "&lt;&lt;#e&lt;&lt; ": "&lt;&lt;e&lt;&lt;" | "&lt;&lt;#f&lt;&lt;": "&lt;&lt;f&lt;&lt;endl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inf</name></cpp:macro> <cpp:value>100000000000000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ff</name></cpp:macro> <cpp:value>first</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ss</name></cpp:macro> <cpp:value>second</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CHAR</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<using>using <namespace>namespace <name>std</name>;</namespace></using>

<comment type="line">//#include &lt;ext/pb_ds/assoc_container.hpp&gt;</comment>
<comment type="line">//#include &lt;ext/pb_ds/tree_policy.hpp&gt;</comment>
<comment type="line">//using namespace __gnu_pbds;</comment>

<comment type="line">//#define ordered_set tree&lt; pair&lt;ll,ll&gt;, null_type,less&lt; pair&lt;ll,ll&gt; &gt;, rb_tree_tag,tree_order_statistics_node_udate&gt;</comment>

<comment type="line">//ll mod=1000000000+7;</comment>
<comment type="line">//ll fact[550];</comment>
<comment type="line">//ll invs[550];</comment>
<comment type="line">//vector &lt; pair&lt;ll,ll&gt; &gt;interval;</comment>
<comment type="line">//ll m1[100001],m2[100001];</comment>
<comment type="line">//vector &lt; pair&lt;ll,ll&gt; &gt; val[100001];</comment>
<comment type="line">//ll val[100001];</comment>
<comment type="line">//ll cnt[100001];</comment>
<comment type="line">//ll sub[100001];</comment>
<comment type="line">//vector &lt; pair&lt;ll,ll&gt; &gt; deph[200001],depl[200001];</comment>
<comment type="line">//map &lt;ll,ll&gt; index;</comment>
<comment type="line">//map &lt;ll,ll&gt; mp;</comment>
<comment type="line">//ll h[200001],l[200001];</comment>
<comment type="line">//ll depth[100001];</comment>
<comment type="line">//vector &lt;ll&gt; child[100001];</comment>
<comment type="line">//vector &lt;ll&gt; undir[101];</comment>
<comment type="line">// vector &lt;ll&gt; adj[200001];</comment>
<comment type="line">// ll vis[200001];</comment>
<comment type="line">// ll col[200001];</comment>
<comment type="line">// ll cnt;</comment>
<comment type="line">//ll vis2[100001];</comment>
<comment type="line">//map &lt;pair&lt;ll,ll&gt;,ll&gt; wt,groot;</comment>
<comment type="line">//ll flag;</comment>
<comment type="line">//map &lt;ll,ll&gt; g;</comment>
<comment type="line">//ll n,m;</comment>
<comment type="line">//ll cnt[101];</comment>
<comment type="line">//ll dist;</comment>
<comment type="line">//ll tot=0;</comment>
<comment type="line">//vector &lt;ll&gt; a;</comment>
<comment type="line">//ll cnt;</comment>
<comment type="line">//ll nodes;</comment>
<comment type="line">//vector &lt;ll&gt; comp[200001];</comment>
<comment type="line">//vector &lt;ll&gt; grp[100001];</comment>
<comment type="line">//ll p[100001];</comment>
<comment type="line">//ll s[100001];</comment>
<comment type="line">//ll dis[300001];</comment>
<comment type="line">//map &lt; pair&lt;ll,ll&gt;,ll &gt; mp;</comment>
<comment type="line">//vector &lt;ll&gt; ans;</comment>
<comment type="line">//map &lt; pair&lt;ll,ll&gt;,ll &gt; e;</comment>
<comment type="line">//ll ans[200001];</comment>
<comment type="line">//vector &lt;ll&gt; arr;</comment>
<comment type="line">//map &lt;ll,ll&gt; m;</comment>
<comment type="line">//ll k;</comment>
<comment type="line">//ll par[100001];</comment>
<comment type="line">//ll d[100001];</comment>
<comment type="line">//ll days[100001];</comment>
<comment type="line">//map &lt; pair&lt;ll,ll&gt;,ll &gt; m;</comment>
<comment type="line">//ll tree[4*1000001];</comment>
<comment type="line">//ll arr[1000000];</comment>
<comment type="line">//string s[100000],revs[100000];</comment>
<comment type="line">//ll dp[100000][2];</comment>
<comment type="line">//ll c[100000];</comment>
<comment type="line">//ll h[100001];</comment>
<comment type="line">// ll p[100001],c[100001];</comment>

<comment type="line">// void bfs(ll x) {</comment>
<comment type="line">//     queue &lt;ll&gt; q;</comment>
<comment type="line">//     q.push(x);</comment>
<comment type="line">//     vis[x]=1;</comment>
<comment type="line">//     ans[x]=1;</comment>
<comment type="line">//     ll k,flag;</comment>
<comment type="line">//     vector &lt;ll&gt;::iterator it;</comment>
<comment type="line">//     while(!q.empty()){</comment>
<comment type="line">//         k = q.front();</comment>
<comment type="line">//         q.pop();</comment>
<comment type="line">//         if(!par[k]){</comment>
<comment type="line">//             ans[k]=1;</comment>
<comment type="line">//         }</comment>
<comment type="line">//         else{</comment>
<comment type="line">//             ans[k]=ans[par[k]]+val[par[k]]+2*(e[make_pair(k,par[k])]-val[par[k]]);</comment>
<comment type="line">//         }</comment>
<comment type="line">//         //cout &lt;&lt; k &lt;&lt; endl;</comment>
<comment type="line">//         flag=0;</comment>
<comment type="line">//         for (it=adj[k].begin();it!=adj[k].end();it++) {</comment>
<comment type="line">//             if(vis[*it]==0) {</comment>
<comment type="line">//                 flag=1;</comment>
<comment type="line">//                 q.push(*it);</comment>
<comment type="line">//                 vis[*it]=1;</comment>
<comment type="line">//                 val[k]=min(val[k],e[make_pair(k,*it)]);</comment>
<comment type="line">//             }</comment>
<comment type="line">//         }</comment>
<comment type="line">//         if(flag==0){</comment>
<comment type="line">//             leaf.pb(ans[k]);</comment>
<comment type="line">//         }</comment>
<comment type="line">//     }</comment>
<comment type="line">// }</comment>

<comment type="line">//ll a,b;</comment>

<comment type="line">//vector &lt;ll&gt; sum;</comment>

<comment type="line">// ll dfs(ll ver, ll c, ll q, ll limit){</comment>
<comment type="line">//     // cout &lt;&lt; ver &lt;&lt; " =&gt; ";</comment>
<comment type="line">//     // deb3(col[ver],c,cnt);</comment>
<comment type="line">//     if(cnt==limit) return 0;</comment>
<comment type="line">//     vis[ver]=q;</comment>
<comment type="line">//     if(col[ver]==c){</comment>
<comment type="line">//         cnt++;</comment>
<comment type="line">//         // deb1(cnt);</comment>
<comment type="line">//     }</comment>
<comment type="line">//     else if(col[ver]!=0){</comment>
<comment type="line">//         vis[ver]=0;</comment>
<comment type="line">//         return -1;</comment>
<comment type="line">//     }</comment>
<comment type="line">//     ll cur,ret;</comment>
<comment type="line">//     ll flag=0;</comment>
<comment type="line">//     for(ll x=0;x!=adj[ver].size();x++){</comment>
<comment type="line">//         cur=adj[ver][x];</comment>
<comment type="line">//         // deb2(cur,vis[cur]);</comment>
<comment type="line">//         if(vis[cur]!=q){</comment>
<comment type="line">//             ret = dfs(cur,c,q,limit);</comment>
<comment type="line">//             if(ret==0){</comment>
<comment type="line">//                 flag=1;</comment>
<comment type="line">//             }</comment>
<comment type="line">//         }</comment>
<comment type="line">//     }</comment>
<comment type="line">//     if(flag==0){</comment>
<comment type="line">//         if(col[ver]==0){</comment>
<comment type="line">//             vis[ver]=0;</comment>
<comment type="line">//             return -1;</comment>
<comment type="line">//         }</comment>
<comment type="line">//         else return 0;</comment>
<comment type="line">//     }</comment>
<comment type="line">//     else return 0;</comment>
<comment type="line">// }</comment>

<comment type="block">/*ll dfs2(ll ver,ll d){
    vis[ver]=1;
    val[ver]=d;
    ll cur;
    ll ret=0;
    ll flag=0;
    for(ll x=0;x!=adj[ver].size();x++){
        cur=adj[ver][x];
        if(!vis[cur]){
            flag=1;
            ret+=dfs2(cur,d+1);
        }
        cnt[ver]=ret;
    }
    if(flag==0){
        return 1;
    }
    else{
        return ret;
    }
}*/</comment>

<comment type="block">/*ll dfs(ll ver,ll par,ll grtsum,ll sum,ll revsum){
    //deb2(sum,grtsum);
    vis[ver]=1;
    ll cur,temp;
    ll ret;
    ll my;
    ll my_ans=0;
    pair &lt;ll,ll&gt; edg;
    for(ll x=0;x!=adj[ver].size();x++){
        cur = adj[ver][x];
        if(!vis[cur]){
            edg.first=ver;
            edg.second=cur;
            temp=groot[edg];
            if(temp==1){
                grtsum+=wt[edg];
            }
            else{
                flag=0;
                grtsum=0;
            }
            //deb1(wt[edg]);
            sum+=wt[edg];
            revsum+=wt[edg];
            my=sum+grtsum;
            //deb1(my);
            my_ans=max(my_ans,my);
            if(revsum-grtsum&lt;grtsum){
                revsum=2*grtsum;
            }
            ret=dfs(cur,ver,grtsum,sum,revsum);
            my_ans=max(my_ans,ret);
        }
    }
    return my_ans;
}*/</comment>

<comment type="block">/*ll dfs2(ll ver,ll par){
    vis2[ver]=1;
    ll cur;
    pair &lt;ll,ll&gt; edg;
    edg.first=ver;
    edg.second=par;
    ll flag=0;
    ll my_ans=0;
    for(ll x=0;x!=adj[ver].size();x++){
        cur = adj[ver][x];
        if(!vis2[cur]){
            flag=1;
            my_ans=max(my_ans,dfs2(cur,ver));
        }
    }
    return my_ans+wt[edg];
}*/</comment>

<comment type="line">//ll m=1000000007;</comment>

<comment type="block">/*ll invmod(ll a,ll n,ll mod){
    ll result = 1;
    while(n&gt;0){
        if(n%2==1){
            result = (result*a)%mod;
        }
        a = (a*a)%mod;
        n = n/2;
    }
    return result;
}

ll fact(ll a,ll mod){
    if(a==0)return 1;
    return (a*fact(a-1,mod))%mod;
}

ll choose(ll n,ll r,ll mod){
    if(n&lt;r)return 0;
    ll num=fact(n,mod);
    ll den=(fact(r,mod)*fact(n-r,mod))%mod;
    return (num*invmod(den,mod-2,mod))%mod;
}*/</comment>

<comment type="block">/*void build(ll node,ll start,ll end,ll cnt){
    if(start==end){
        tree[node]++;
        return;
    }
    ll mid=(start+end)/2;
    if(cnt&lt;=mid)build(2*node+1,start,mid,cnt);
    else build(2*node+2,mid+1,end,cnt);
    tree[node] = tree[2*node+1] + tree[2*node+2];
}*/</comment>

<comment type="block">/*ll query(ll node,ll start,ll end,ll lef,ll riht){
    if(end&lt;lef || start&gt;riht){
        return 0;
    }
    else if(start&gt;=lef &amp;&amp; end&lt;=riht){
        return tree[node];
    }
    else{
        ll mid=(start+end)/2;
        //cout &lt;&lt; mid &lt;&lt; "\n";
        //cout &lt;&lt; (query(2*node+1,start,mid,lef,riht)) &lt;&lt; "\n";
        //cout &lt;&lt; (query(2*node+2,mid+1,end,lef,riht)) &lt;&lt; "\n";
        return query(2*node+1,start,mid,lef,riht) + query(2*node+2,mid+1,end,lef,riht);
    }
}*/</comment>

<comment type="line">//ll step[4000001];</comment>
<comment type="line">//map &lt; pair&lt;ll,ll&gt; ,ll&gt; mp;</comment>
<comment type="line">//ll w[300001];</comment>

<comment type="line">//multiset &lt;ll&gt; s[300001];</comment>

<comment type="line">//ll mod=998244353;</comment>

<comment type="block">/*ll fact(ll a){
    if(a==0){
        return 1;
    }
    return (a*fact(a-1))%mod;
}*/</comment>

<comment type="line">//ll mod=1000000000+7;</comment>

<comment type="line">// ll mod = 998244353;</comment>
<comment type="line">//</comment>
<comment type="line">// ll power(ll a,ll y){</comment>
<comment type="line">//     if(y==0)return 1;</comment>
<comment type="line">//     ll p = power(a, y/2) % mod;</comment>
<comment type="line">//     p = (p * p) % mod;</comment>
<comment type="line">//     return (y%2==0)? p : (a * p) % mod;</comment>
<comment type="line">// }</comment>

<comment type="block">/*ll invmod(ll a){
    return power(a, mod-2);
}*/</comment>

<comment type="line">//vector &lt;ll&gt; v[100000];</comment>
<comment type="line">//vector &lt;ll&gt; pref[100000];</comment>

<comment type="line">//ll isNode[1000001];</comment>

<comment type="block">/*ll helper(ll B,ll cnt){
    ll temp=1;
    for(ll x=2;x&lt;=cnt;x++){
        temp*=(B+cnt-x);
    }
    for(ll x=2;x&lt;=cnt-1;x++){
        temp/=x;
    }
    return temp;
}*/</comment>

<comment type="block">/* Returns length of LCS for X[0..m-1], Y[0..n-1] */</comment>

<comment type="block">/*ll parent[20][100001];
ll level[100001];

void par_dfs(ll k, ll par, ll lvl)
{
    parent[0][k]=par;
    level[k]=lvl;
    for(ll i=0;i&lt;adj[k].size();i++)
    {
        ll it=adj[k][i];
        if(it==par)
            continue;
        par_dfs(it, k, lvl+1);
    }
}

void precompute()
{
    for(ll i=1;i&lt;20;i++)
        for(ll j=1;j&lt;=100000;j++)
            if(parent[i-1][j])
                parent[i][j]=parent[i-1][parent[i-1][j]];
}*/</comment>

<comment type="block">/*ll LCA(ll u, ll v)
{
    if(level[u]&lt;level[v])
        swap(u,v);
    ll diff=level[u]-level[v];
    for(ll i=20-1;i&gt;=0;i--)
    {
        if((1&lt;&lt;i) &amp; diff)
        {
            u=parent[i][u];
        }
    }
    if(u==v)
        return u;
    for(ll i=20-1;i&gt;=0;i--)
    {
        if(parent[i][u] &amp;&amp; parent[i][u]!=parent[i][v])
        {
            u=parent[i][u];
            v=parent[i][v];
        }
    }
    return parent[0][u];
}*/</comment>

<comment type="block">/*void recur(ll cur,ll d,ll n){
    //if(a.size()&gt;1000000)cout &lt;&lt; "Culprit\n";
    a.pb(cur);
    vis[cur]=1;
    if(d&gt;dist){
        a.pop_back();
        vis[cur]=0;
        return;
    }
    if(cur==n){
        tot++;
        for(ll x=0;x!=a.size();x++){
            cnt[a[x]]++;
        }
        vis[cur]=0;
        a.pop_back();
        return;
    }
    ll i;
    for(i=0;i!=adj[cur].size();i++){
        if(!vis[adj[cur][i]])recur(adj[cur][i],d+1,n);
    }
    a.pop_back();
    vis[cur]=0;
}*/</comment>

<comment type="line">// ll ans;</comment>
<comment type="line">// ll pre[100001];</comment>
<comment type="line">// ll a[100001];</comment>
<comment type="line">// pair &lt;ll,ll&gt; dg[100001];</comment>
<comment type="line">//</comment>
<comment type="line">// void binary_search(ll time,ll l,ll r){</comment>
<comment type="line">//     if(l&gt;r)return;</comment>
<comment type="line">//     ll mid=(l+r)/2;</comment>
<comment type="line">//     //if(i==0)deb2(mid,tot);</comment>
<comment type="line">//     if(leaf[mid]&lt;=time){</comment>
<comment type="line">//         out=mid;</comment>
<comment type="line">//         binary_search(time,mid+1,r);</comment>
<comment type="line">//     }</comment>
<comment type="line">//     else{</comment>
<comment type="line">//         binary_search(time,l,mid-1);</comment>
<comment type="line">//     }</comment>
<comment type="line">// }</comment>

<comment type="line">// ll a[1000000];</comment>
<comment type="line">// ll vis[1000001];</comment>

<comment type="line">// ll my_ceil_div(ll p,ll q){</comment>
<comment type="line">//     if(p%q==0){</comment>
<comment type="line">//         return (p/q);</comment>
<comment type="line">//     }</comment>
<comment type="line">//     else{</comment>
<comment type="line">//         return ((p/q)+1);</comment>
<comment type="line">//     }</comment>
<comment type="line">// }</comment>

<comment type="line">// bool compare(pair&lt;ll,ll&gt; &amp;a, pair&lt;ll,ll&gt; &amp;b){</comment>
<comment type="line">//     return (a.second &lt; b.second);</comment>
<comment type="line">// }</comment>

<comment type="line">// bool str_compare(string s1,string s2){</comment>
<comment type="line">//     ll i=0,j=0;</comment>
<comment type="line">//     while(s1[i]!='\0' &amp;&amp; s2[j]!='\0'){</comment>
<comment type="line">//         if(s1[i]&lt;s2[j]){</comment>
<comment type="line">//             return true;</comment>
<comment type="line">//         }</comment>
<comment type="line">//         else if(s1[i]&gt;s2[j]){</comment>
<comment type="line">//             return false;</comment>
<comment type="line">//         }</comment>
<comment type="line">//         i++;</comment>
<comment type="line">//         j++;</comment>
<comment type="line">//     }</comment>
<comment type="line">//     if(s1[i]=='\0'){</comment>
<comment type="line">//         return true;</comment>
<comment type="line">//     }</comment>
<comment type="line">//     else{</comment>
<comment type="line">//         return false;</comment>
<comment type="line">//     }</comment>
<comment type="line">// }</comment>

<comment type="line">// ll vis[50001][50001];</comment>
<comment type="line">// ll lef[50001][50001];</comment>
<comment type="line">// ll righ[50001][50001];</comment>
<comment type="line">// ll u[50001][50001];</comment>
<comment type="line">// ll d[50001][50001];</comment>

<comment type="line">// ll prime[1000001];</comment>

<function><type><name>int</name></type> <name>main</name><parameter_list>()</parameter_list><block>{
    <expr_stmt><expr><name>fast_io</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ll</name></type> <name>k</name></decl>,<decl><type ref="prev"/><name>n</name></decl>,<decl><type ref="prev"/><name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>cin</name> <operator>&gt;&gt;</operator> <name>k</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>k</name><operator>--</operator></expr>)</condition><block>{
    	<expr_stmt><expr><name>cin</name> <operator>&gt;&gt;</operator> <name>n</name></expr>;</expr_stmt>
    	<decl_stmt><decl><type><name>ll</name></type> <name><name>a</name><index>[<expr><name>n</name></expr>]</index></name></decl>;</decl_stmt>
    	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{
    		<expr_stmt><expr><name>cin</name> <operator>&gt;&gt;</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    	}</block></for>
    	<expr_stmt><expr><call><name>sort</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>a</name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    	<decl_stmt><decl><type><name>ll</name></type> <name>ans</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    	<decl_stmt><decl><type><name>ll</name></type> <name>temp</name></decl>;</decl_stmt>
    	<for>for<control>(<init><expr><name>i</name><operator>=</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</init><condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition><incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{
    		<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>min</name><argument_list>(<argument><expr><name>n</name><operator>-</operator><name>i</name></expr></argument>,<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    		<expr_stmt><expr><name>ans</name><operator>=</operator><call><name>max</name><argument_list>(<argument><expr><name>ans</name></expr></argument>,<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    	}</block></for>
    	<expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <name>ans</name> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
    }</block></while>
}</block></function>
</unit>
